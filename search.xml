<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>node中间件</title>
    <url>/2020/05/03/node%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><a id="more"></a>
<p>中间件的本质就是一个请求处理方法，我们把用户从请求到响应dd 整个过程分发到多个中间件中去处理，这样有利于提高代码的灵活性，动态可扩展性。</p>
<ul>
<li><p>1、应用程序级别中间件</p>
<blockquote>
<p>万能匹配（不关心请求路径和请求方法的中间件，也就是说任何请求都会进入这个中间件。）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req , res , next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求进来了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以/xxx开头的路径中间件</span></span><br><span class="line">app.use(<span class="string">'/a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>2、路由中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req ,res</span>) </span>&#123;&#125;)</span><br><span class="line">app.post(<span class="string">'/'</span>)</span><br><span class="line">app.put()</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、第三方中间件<br>  body-parser</p>
</li>
<li><p>4、错误处理中间件<br>如果之前的中间件中err中传入了参数那么会直接找到错误处理中间件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err , req , res , next</span>)</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).json(&#123;</span><br><span class="line">        err_code : <span class="number">500</span>,</span><br><span class="line">        message : err.message</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie相关</title>
    <url>/2020/05/02/cookie%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>http协议是一个无状态协议，他不会记录用户的信息。这是我们需要使用cookie来储存用户的信息。</p>
<ul>
<li>cookie中的信息是存储在浏览器中的，因此只能存储一些非铭感信息。</li>
</ul>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>为了解决cookie的问题，我们引入session。<br>超市   -   电子柜    -    消费者<br>电子柜（服务端）   给你一个凭证（cookie）凭证是唯一的，不可重复，一点丢失，不可找回。     你（客户端）<br>express-session这个插件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加session  </span></span><br><span class="line">req.session.user = user</span><br><span class="line"><span class="comment">//读取session</span></span><br><span class="line">req.session.user</span><br><span class="line"><span class="comment">//删除session</span></span><br><span class="line">req.session.user = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> req.session.user</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2020/04/30/promise/</url>
    <content><![CDATA[<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><a id="more"></a>
<h1 id="异步处理方式"><a href="#异步处理方式" class="headerlink" title="异步处理方式"></a>异步处理方式</h1><p>异步进程可以通过回调函数的形式来执行，如果需要控制异步程序执行的先后顺序那么就需用在异步函数的回调函数中套入另一个回调函数，如果异步程序比较多。这样就形成了回调地狱。</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>为了解决异步嵌套，es6中新增了一个api promise</p>
<h1 id="promise-1"><a href="#promise-1" class="headerlink" title="promise"></a>promise</h1><p>promise是一个异步容器,promise本身不是异步，只是用来存储异步进程</p>
<ul>
<li>1、基本使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建promise容器</span></span><br><span class="line"><span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2、解决回调地狱<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1 = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2 = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text1.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p3 = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p2    <span class="comment">//这里return可以呗后面的then接收/处理</span></span><br><span class="line">                    <span class="comment">//这里我们return一个promise对象同时可以被后面的then接受处理</span></span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p3</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;&#125; , <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
通过链式调用我们就可以解决异步程序先后执行顺序同时避免回调地狱的发送。但是上面的的代码有重复的东西，我们对他进行封装。新建一个js文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">pathfill</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">reslove , reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(pathfill,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样我们的代码就变得非常漂亮</li>
</ul>
<h1 id="promise使用场景"><a href="#promise使用场景" class="headerlink" title="promise使用场景"></a>promise使用场景</h1><p>promise是用来解决异步回调嵌套的问题，一般需要大量异步操作的地方都可以使用promise。例如 ajax数据请求，mongodb</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h1><blockquote>
<p>是一个符号，一个描述客观事物的符号，可以被计算机识别，并且输入给计算机处理的数据的一个符号集合（内存）</p>
</blockquote>
<h1 id="什么是数据元素"><a href="#什么是数据元素" class="headerlink" title="什么是数据元素"></a>什么是数据元素</h1><blockquote>
<p>由数据组成的有意义的集合体的基本单位    人   ，  摄影师   ， 老师</p>
</blockquote>
<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><blockquote>
<p>数据结构与计算机存储、组织数据的方式，精心选择的数据结构可以带来更高的运行或者存储效率。</p>
</blockquote>
<h1 id="由哪些数据结构"><a href="#由哪些数据结构" class="headerlink" title="由哪些数据结构"></a>由哪些数据结构</h1><ul>
<li><p>1、栈</p>
</li>
<li><p>2、堆</p>
</li>
<li><p>3、队列</p>
</li>
<li><p>4、数组</p>
</li>
<li><p>5、散列表</p>
</li>
<li><p>6、链表</p>
</li>
<li><p>7、图</p>
</li>
<li><p>8、树</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组是一串连续存储的数据，但是在js中的数组严格意义上来说不算是数组，他的存储方式与传统数组不同。</p>
</blockquote>
<blockquote>
<p>正真的数组他的删除和插入效率会很低，因为数组是一串连续存储的数据，为了保证他的连续他会自动的调整数据的位置以保证是连续存储</p>
</blockquote>
</li>
</ul>
<h1 id="1、栈与队列"><a href="#1、栈与队列" class="headerlink" title="1、栈与队列"></a>1、栈与队列</h1><p>栈是一种受限制的线性表，数据插入，删除，查找的时候不能随心所欲。(先进后后出，后进先出)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    push(ele)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出战</span></span><br><span class="line">    pop()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取栈顶元素</span></span><br><span class="line">    peek()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    isEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈的元素个数</span></span><br><span class="line">    size()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空栈</span></span><br><span class="line">    clean()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items == [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> stack()</span><br><span class="line">stack.push()</span><br><span class="line">stack.size()</span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转二进制</span></span><br><span class="line"><span class="keyword">const</span> binary = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = <span class="keyword">new</span> stack()</span><br><span class="line">    <span class="keyword">let</span> rem = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> _binary = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        rem = number % <span class="number">2</span>;</span><br><span class="line">        stack.push(rem);</span><br><span class="line">        number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        _binary += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _binary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binary(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<h2 id="1-1、js是单线程原理"><a href="#1-1、js是单线程原理" class="headerlink" title="1.1、js是单线程原理"></a>1.1、js是单线程原理</h2><ul>
<li><p>1、js为什么设计成单线程：两个人同时操作同一个dom这时不知道该听谁的。</p>
</li>
<li><p>2、js是单线程，浏览器是多进程的。</p>
</li>
<li><p>3、主线程自上而下，代码进栈、执行完毕后出栈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来1、2</span></span><br></pre></td></tr></table></figure></li>
<li><p>4、执行上下文：是当前js代码解析和执行所在的环境，所有的js代码都在执行上下文中去执行（执行环境）</p>
<ul>
<li>1、全局执行上下文：他是默认的也是最基础的执行上下文，任何函数都位于这个全局执行上下文。</li>
<li>2 、函数执行上下文：每次调用函数的时候，会为这个函数创建一个新的执行上下文。每个函数都有自己的函数执行上下文</li>
<li>3、eval函数执行上下文：理解为执行环境，如果你传入的是字符串并且js代码符合规范，那么这段js字符串会被执行。<br>这里我们对执行上下文与作用域来做个区别：</li>
<li>1、作用域：作用域是在函数定义的时候就已经定好了，可以理解为静态的。</li>
<li>2、执行上下文：是this的指向，this指向是谁调用就指向谁，也就是在执行上下文中执行谁，这个是动态的。<blockquote>
<p>当打开浏览器时js引擎会在执行栈中创建全局执行上下文，创建完成后开始从上至下执行js脚本中的代码，创建全局作用域，每当遇到函数调用就会创建函数执行上下文，并创建函数作用域，之后执行函数中的代码，当函数执行完毕后开始，会跳出函数的执行上下文，同时垃圾回收机制会清除局部作用域，之后把权限有再次交给全局执行上下文，依次执行代码直到代码执行完毕，这是全局执行上下文不会被消除（只有关闭浏览器才会消除），当浏览器关闭js引擎会触发垃圾回收机制清除执行栈中的函数声明，以及变量声明。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>5、js中的堆栈</p>
<ul>
<li>栈：一般用来存储基本数据类型，以及引用类型的内容地址。</li>
<li>堆：存放引用类型的内容，是真实的内存空间是开辟的。</li>
<li>执行栈：执行栈中会把js脚本非执行代码（也就是函数定义/变量定义入栈单不出栈，而对于执行的代码他们会依次入栈出栈，当js脚本中的代码执行完毕后，执行栈中就只剩下非执行代码了，那么这些代码会被垃圾回收机制清除，以保证下一次执行其他脚本时执行栈中执行上下文不会收到影响）中的所有代码一次</li>
</ul>
</li>
<li><p>6、作用域<br>  作用域</p>
<pre><code>- 1、词法作用域：也就是平时使用的作用域，全局作用域（GO）、函数作用域(AO)、会变量提升。
- 2、动态作用域：就是this对应的作用域，谁调用作用域就是谁。</code></pre></li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种运算受限的线性表，先进先出</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>node</title>
    <url>/2020/04/22/node/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="node-js是什么？"><a href="#node-js是什么？" class="headerlink" title="node.js是什么？"></a>node.js是什么？</h1><ul>
<li><p>node.js一个让javascript运行在服务端的开发平台</p>
<ul>
<li><p>node.js不是一门语言</p>
</li>
<li><p>node.js不是库，不是框架</p>
</li>
<li><p>node.js是一个JavaScript运行时环境</p>
</li>
<li><p>node.js是可以解析和执行js代码，以前只有浏览器可以解析JavaScript</p>
</li>
<li><p>也就是说有了node，JavaScript可以完全脱离浏览器运行。</p>
</li>
<li><p>构建与chrome的v8引擎上</p>
<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以识别他们，引擎会帮你去解析和执行</li>
<li>chrome的v8引擎，是目前公认执行js最快的引擎</li>
<li>node的作者把v8引擎提取出来，编译成了JavaScript的运行环境</li>
</ul>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>EcmaScript</li>
<li>Bom</li>
<li>Dom</li>
</ul>
</li>
<li><p>node中的JavaScript</p>
<ul>
<li>只有EcmaScript</li>
<li>没有Dom和Bom</li>
<li>node这个JavaScript运行时环境为JavaScript提供了一些服务器级别的操作API<ul>
<li>例如文件读写</li>
<li>网络服务的构建</li>
<li>网络通讯</li>
<li>http服务器等<ul>
<li>node.js使用机制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件驱动</p>
</li>
<li><p>非阻塞io模型，简单来说就是异步操作</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>node.js生态系统<ul>
<li>npm（世界上最大的开源库生态系统）</li>
<li>绝大数的JavaScript包都存放在npm上，让开发人员更方便的下载使用</li>
</ul>
</li>
</ul>
<h1 id="node-js能做什么？"><a href="#node-js能做什么？" class="headerlink" title="node.js能做什么？"></a>node.js能做什么？</h1><pre><code>- web服务器后台
- 命令行工具（npm，hexo）
- 一些资源
    - 《深入淡出Node.js》
    - 《node.js权威指南》</code></pre><h1 id="node-js学完能学到什么？"><a href="#node-js学完能学到什么？" class="headerlink" title="node.js学完能学到什么？"></a>node.js学完能学到什么？</h1><pre><code>- B/S编程模型
    - Brower-server
    - back-end
    - 任何服务端技术这种BS编译模型都是一样的，和语言无关

- 模块化编程
    - 通过commin.js导入导出对应模块
- 异步编程
    - 回调函数
    - promise
    - async
    - generator</code></pre><h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><pre><code>使用node编写应用程序主要就是在使用
    - ECMAscript
    - 核心模块
        - fs模块
        - http模块
        - url模块
    - 第三方模块
    - 自定义模块

- 1、什么是模块化
    - 文件作用域
    - 通讯规则




- commonJS模块规范
在node中的JavaScript还有一个跟重要的概念，模块系统
 - 模块作用域
 - 使用require方法来加载模块
 - 使用export 接口对象来导出模块中的成员

 - 加载 require
    两个作用
        - 执行被加载 模块的代码
        - 得到被加载模块中的exports导出接口对象
 - 导出 export
    - node中是模块作用域，默认文件中所有的成员只在当前文件模块有效
    - 对希望可以被其他模块访问的成员，我们需要把这些公开的成员挂在到exprots接口对象中就可以了
        - 导出多个成员
        <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span>.a = <span class="number">123</span></span><br><span class="line"><span class="keyword">export</span>.b = <span class="number">456</span></span><br><span class="line"><span class="keyword">export</span>.c=<span class="number">789</span></span><br></pre></td></tr></table></figure>
        - 导出单个成员
        <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="模块原理-接下来我们介绍一下原理"><a href="#模块原理-接下来我们介绍一下原理" class="headerlink" title="模块原理 接下来我们介绍一下原理"></a>模块原理 接下来我们介绍一下原理</h1><pre><code>这个原理有点像构造函数，node中只有模块作用.每个模板内部都有一个自己的对象module对象，在module对象中也有一个对象export的一个空对象。
默认在代码的最底层有一句话，return module.exports。而其中还有一局代码是var express = module.export  因此才有了export.a = 123这种导入。其实本质还是对module对象中的export导出。</code></pre><h1 id="模块查找机制"><a href="#模块查找机制" class="headerlink" title="模块查找机制"></a>模块查找机制</h1><h1 id="require-优先从缓存中加载"><a href="#require-优先从缓存中加载" class="headerlink" title="require  优先从缓存中加载"></a>require  优先从缓存中加载</h1><h1 id="标识符分析"><a href="#标识符分析" class="headerlink" title="标识符分析"></a>标识符分析</h1><pre><code>- 路径形式的模块
&gt;/(当前文件模块所属磁盘根路径)   ./   ../
- 核心模块
&gt;直接应用，这些核心文件已经被编译到二进制文件中了。
- 第三方模板
不可能有任何一个第三方包与核心模块的名字是一样的
&gt;先找到当前文件中的node_modules，你所引入的包/ 再去找到包中对应的pack.json文件/再去找到里面的main属性/main属性中就记录了当前包的入口模块。

&gt;如果pack.json不存在，并且main对应的路径是有问题的那么，那么pack.json文件在同一目录下的index.js文件      </code></pre><h1 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h1><pre><code>- 文件读取

    - fs.readFile(文件中存储的其实二进制0 1)</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/hello.text'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = data.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>    这里他呗默认转为了16进制，外面可以通过tostring方法转化成我们能认识的字符


- 写文件
    - fs.writeFile</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">'./data/holleword.text'</span>,<span class="string">"家好  我是holleword"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    <span class="comment">//没错error = null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h1><p>node可以非常轻松的构建一个web服务器，在node中提供一个核心模块：http</p>
<ul>
<li><p>1、加载http核心模块</p>
<blockquote>
<p>var http = require(‘http’)</p>
</blockquote>
</li>
<li><p>2、使用http.createServer（）方法创建一个web服务器，返回一个Server实例</p>
<blockquote>
<p>var server = http.createServer()</p>
</blockquote>
</li>
<li><p>3、服务器作用</p>
<p>  1、对数据提供服务</p>
<p>  2、发送请求</p>
<p>  3、接受数据</p>
<p>  4、处理请求</p>
<p>  5、响应请求</p>
<ul>
<li><p>配置头部信息</p>
<blockquote>
<p>res.setHeader(‘content-type’ , ‘text/plain’; charset=utf-8)</p>
</blockquote>
<p>  文件类型（content-type）</p>
<ul>
<li><p>非文字类型的都要把charset=utf-8去掉</p>
</li>
<li><p>text/plain 普通文本</p>
</li>
<li><p>text/html 就是html格式文本<br><a href="https://tool.oschina.net/" target="_blank" rel="noopener">工具</a><br>除了配置请求头中的content-type还可以在html页面的meta标签中声明他</p>
<p>文本编码格式</p>
<ul>
<li>在服务器默认发送的数据，默认都是utf8编码的内容</li>
<li>但是浏览器不知道你是什么类型的编码，你也没有告诉浏览器你发送的数据是什么编码</li>
<li>那么浏览器在不知道内容编码的情况下，默认按照当前操作系统的默认编码去解析</li>
<li>中文操作系统的默认编码格式是 gdk</li>
</ul>
</li>
</ul>
</li>
<li><p>监听request请求，当有客户端发送请求会自动执行request请求事件</p>
</li>
<li><p>服务端重定向</p>
<ul>
<li><p>以3开头的状态码都是用于重定向的。</p>
</li>
<li><p>首先设置状态码</p>
<blockquote>
<p>res.statusCode = 302</p>
</blockquote>
<p>301 永久重定向  浏览器会记住<br>302 零时重定向  浏览器记不住</p>
</li>
<li><p>配置重定向地址</p>
<blockquote>
<p>res.setHeader(‘Location’,’/‘)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'收到客户端请求'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求地址是'</span>+req.url)</span><br><span class="line">    <span class="comment">//req.url获取获取请求的url信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//res中有wrte方法，write可以多次使用但是最后必须使用end结束，如果不接受那么程序会继续等待</span></span><br><span class="line">    res.write(<span class="string">'holle'</span>)</span><br><span class="line">    res.write(<span class="string">'word'</span>)</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4、绑定端口号，启动服务器</p>
<blockquote>
<p>server.listen(3000)</p>
</blockquote>
</li>
<li><p>5、配置路由响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h1><p>用来帮你辅助操作路径的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取给定路径的文件名</span></span><br><span class="line">path.basename(<span class="string">'路径'</span>)   <span class="comment">//获取文件明年</span></span><br><span class="line">path.basename(<span class="string">'c/a/index.js'</span>)   <span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取给定路径的文件名</span></span><br><span class="line">path.dirname(<span class="string">'路径'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件扩展名</span></span><br><span class="line">path.extname(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为绝对路径</span></span><br><span class="line">path.isAbsolyte(path)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取分析路径中所有信息</span></span><br><span class="line">path.parse(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径拼接</span></span><br><span class="line">path.join(<span class="string">''</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="node中的其他成员"><a href="#node中的其他成员" class="headerlink" title="node中的其他成员"></a>node中的其他成员</h1><p>每个模块中，除了require、exports等模块，还有两个特殊成员。</p>
<ul>
<li>__dirname 可以获取当前文件模块所属目录的绝对路径 （动态的获取）<br>` __filename 可以获取当前文件的绝对路径 （动态的获取） </li>
</ul>
<p>在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node命令所处的路径（不是bug，人家这样设计是有使用场景的）<br>为了解决相对路径不可靠的问题，我们把可以使用<strong>dirname/</strong>filename来动态获取不同计算机不同存储位置的路径。在路径拼接过程中，为了避免手动修改路径出错，所以推荐多使用path.join()来辅助拼接，在以后的操作中尽可能的把绝对路径转化为相对路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/public/'</span>,express.static(path.join(__dirname,<span class="string">'./public'</span>)))</span><br><span class="line">app.use(<span class="string">'/node_modules'</span>,express.static(path.join(__dirname,<span class="string">'./node_modules'</span>)))</span><br></pre></td></tr></table></figure>
<h1 id="node中的核心模块"><a href="#node中的核心模块" class="headerlink" title="node中的核心模块"></a>node中的核心模块</h1><p>fs模块<a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html" target="_blank" rel="noopener">官方文档</a>，http模块，path路径模块，os操作系统模块。。。</p>
<h1 id="node多文件执行"><a href="#node多文件执行" class="headerlink" title="node多文件执行"></a>node多文件执行</h1><ul>
<li><p>node中没有全局作用域，只有模块作用域。</p>
<pre><code>也就是说不同文件中的内容在同一页面执行引入的时候不会相互影响。外部取不到内部的数据，内部也取不到外部的数据，但是可以执行代码。</code></pre></li>
<li><p>那么如何让node中的模块之间通讯呢？</p>
<ul>
<li>export导出模块<br>  常规导出的是express这个对象，需要通过打点或者解构来获取和调用里面的多内容<blockquote>
<p>export   abc</p>
</blockquote>
</li>
<li>require的作用<ul>
<li>1、加载并执行文件模块中的代码</li>
<li>2、拿到被加载文件模块导出的接口对象</li>
</ul>
</li>
</ul>
</li>
<li><p>ap地址和端口号</p>
<ul>
<li>每一个ip指向了一台服务器（定位计算机）</li>
<li>服务器中的每一个物联网通讯的应用程序都对应了一个端口号（端口号定位具体应用程序）</li>
<li>端口号范围 0 - 65535之间</li>
</ul>
</li>
</ul>
<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><pre><code>模板引擎起源于服务器，最后发展到了前端
- art-template（js）
- </code></pre><h1 id="node中静态资源处理方法"><a href="#node中静态资源处理方法" class="headerlink" title="node中静态资源处理方法"></a>node中静态资源处理方法</h1><p>node中为了方便静态资源管理放在public文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//得到用户的路径</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">    <span class="comment">//真的读取这个文件</span></span><br><span class="line">    fs.readFile(<span class="string">"./static/"</span> + pathname,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//如果此文件不存在，就应该用404返回</span></span><br><span class="line">            fs.readFile(<span class="string">"./static/404.html"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">                res.writeHead(<span class="number">404</span>,&#123;<span class="string">"Content-type"</span>:<span class="string">"text/html;charset=UTF8"</span>&#125;);</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>);</span><br></pre></td></tr></table></figure>


<h1 id="实现Apache"><a href="#实现Apache" class="headerlink" title="实现Apache"></a>实现Apache</h1><h1 id="推荐JavaScript的编写规范的书"><a href="#推荐JavaScript的编写规范的书" class="headerlink" title="推荐JavaScript的编写规范的书"></a>推荐JavaScript的编写规范的书</h1><blockquote>
<p>编写可维护的javascript</p>
</blockquote>
<h1 id="服务器渲染"><a href="#服务器渲染" class="headerlink" title="服务器渲染"></a>服务器渲染</h1><blockquote>
<p>也就是说在服务器使用模板引擎<br>    - 客户端渲染<br>        html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。<br>    - 服务端渲染<br>    服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。（也就是通过模板引擎把数据在服务端的时候就渲染好，收到请求之间发送页面）</p>
</blockquote>
<pre><code>- 客户端渲染与服务器渲染的区别
    - 客户端渲染不利于seo搜索引擎优化，也就是说客户端渲染的数据爬虫爬不到
    - 服务器渲染是可以被爬虫爬取到的，客户端的异步渲染是很难被爬虫爬取到的。
    - 所以一个网站，是服务器与客户端结合渲染来做的</code></pre><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><pre><code>package.json包说明书，描述你的项目使用了哪些npm包

--save 会把你安装的包放在package.json中。

同时package.json可以通过npm init初始化出来
而如果没有node——module有package.json使用npm install  会更具package.json中的依赖还原你的node_module


npm  是一个网站
npm  是一个命令行工具</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install (i)</span><br><span class="line"></span><br><span class="line">npm install 包名 --save(S)</span><br><span class="line">npm uninstall 包名</span><br><span class="line">npm help  查看使用帮助</span><br></pre></td></tr></table></figure>
<pre><code>npm被墙问题
    npm是国外网站一般使用cnpm
        npm  install --global cnpm
    如果不想通过npm安装cnpm也可以
        npm install 包 --registry=https：//registry.npm.taobao.org
        这样会比较麻烦每次安装都需要写后缀

        推荐这样
        npm config set registry https：//registry.npm.taobao.org

package.json/package-lock.json  
    - package-lock.json中存储的你项目中node_module所有的依赖信息，当你的node_module从新安装依赖的时候会比没有安装之前的速度更快。
    - 从文件来看，有一个lock  这个锁是用来锁定版本的，如果你下载的下面时1.1版本的，如果没有lock那么你npm i的时候就会默认给你安装最新的版本</code></pre><h1 id="JavaScript模块化"><a href="#JavaScript模块化" class="headerlink" title="JavaScript模块化"></a>JavaScript模块化</h1><p>JavaScript天生不支持模块化，如果浏览器需要模块化那么需要引入第三方库<br>    - require.js    AMD<br>    - sea.js    CMD<br>    上面两中都是浏览器模块化规范<br>    - common.js   common<br>    当然还有UMD、es6中的modules</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Node中我们开启的web服务是一个完全的黑盒子，所有资源都不允许用户来访问，用户可以访问的内容具体由开发人员编写设计为准。</li>
<li>在Node中可以把一个url地址处理的非常漂亮  </li>
</ul>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>vue从基础到熟悉</title>
    <url>/2020/04/03/vue%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E7%86%9F%E6%82%89/</url>
    <content><![CDATA[<h1 id="vue从基础到熟悉"><a href="#vue从基础到熟悉" class="headerlink" title="vue从基础到熟悉"></a>vue从基础到熟悉</h1><a id="more"></a>

<h1 id="一、基本指令"><a href="#一、基本指令" class="headerlink" title="一、基本指令"></a>一、基本指令</h1><ul>
<li><p>v-if</p>
<p>  如果v-if中的值为true，会渲染对应绑定的元素，若为false不会渲染对应绑定元素。（v-if有惰性）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">'istrue'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      istrue: true</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>v-show</p>
<p>  如果v-show中的值为true，会渲染并显示对应绑定的元素，若为false会渲染对应绑定元素但会被隐藏起来（display：none）。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-show=<span class="string">'istrue'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      istrue: true</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>v-for</p>
<p>  会循环遍历对应数据中的内容，并把每一次遍历出来的值渲染到dom中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">for</span>=<span class="string">"(item, index) in items"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;&#123;index&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      list: [a,b,c]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>v-text</p>
</li>
</ul>
<p>可以把数据渲染到dom中，不能识别标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-text=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: 'holle word'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-html<br>把数据渲染到dom中，可以识别标签。不会渲染内部的scrpit，为了防止xss攻击。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-html=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: '&lt;h1&gt;holle word&lt;/</span>h1&gt;<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-bind</li>
</ul>
<p>属性绑定，通过获取data中的值来控制（style，class，href，src等等的标签属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-bind:<span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span> :style = <span class="string">'&#123;color:red,fontSize:font&#125;'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: 'holle',</span></span><br><span class="line"><span class="regexp">      red: 'red',</span></span><br><span class="line"><span class="regexp">      font: '15px'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-model</li>
</ul>
<p>绑定数据源（数据双向绑定），他一些修饰符 </p>
<pre><code>- 1、lazy懒加载（输入时不会变，光标离开时更改数据）
- 2、number限制数据类型（加上这个属性只能显示数字部分，字符串会默认清空）
- 3、trim去空格（去除输入内容中的空格）</code></pre><p>可以使用数据双向绑定完成很多有用的东西，比如在一个地方需改数据，同时修改其他地方的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span>&gt;</span><br><span class="line">      &lt;input type:<span class="string">'text'</span> v-model=<span class="string">'text'</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">      &lt;label for='istrue'&gt;&#123;&#123;text&#125;&#125;&lt;/</span>label&gt;</span><br><span class="line">      &lt;input type:<span class="string">'text'</span> v-model.lazy=<span class="string">'text'</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">      &lt;label for='istrue'&gt;&#123;&#123;text&#125;&#125;&lt;/</span>label&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: false</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>v-on</li>
</ul>
<p>绑定事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input @:click = <span class="string">'letgo'</span>/&gt;</span><br><span class="line">            &lt;input v-on:click = <span class="string">''</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="string">"ok"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      letgo() &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-once</li>
</ul>
<p>对应标签中的数据只会渲染最开始的数据，渲染完成后不会根据数据的改变而改变.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span> v-once&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: "ok"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="二、全局api"><a href="#二、全局api" class="headerlink" title="二、全局api"></a>二、全局api</h1><ul>
<li>自定义指令（Vue.directive(“name”,function(el,binding,vnode){})）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span> v-news&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.directive('news',function(el,binding,vnode)&#123;</span></span><br><span class="line"><span class="regexp">  console.log(el)</span></span><br><span class="line"><span class="regexp">  el:被绑定的元素</span></span><br><span class="line"><span class="regexp">  console.log(binding)</span></span><br><span class="line"><span class="regexp">  binding：被绑定元素的详细信息，</span></span><br><span class="line"><span class="regexp">  console.log(vnode)</span></span><br><span class="line"><span class="regexp">  vnode：虚拟dom节点</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: "ok"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
自定义指令有自己独特的生命周期</li>
</ul>
<p>自定义指令生命周期<br>    - 1、bind：指令第一次绑定到元素上时，触发。<br>    2、inserted：被绑定元素插入父节点的时候调用<br>    3、update：被绑定的元素模板更改时调用<br>    4、componentUpdate：被绑定的元素所在模板更新完成时调用<br>    5、unbind：只调用一次，指令解绑的时候</p>
<ul>
<li>构造器的延申（Vue.extend）</li>
</ul>
<p>Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的vue实例构造器，经常服务于vue.component用来生成的组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id = <span class="string">"author"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;author&gt;&lt;/</span>author&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">let author = Vue.extend(&#123;</span></span><br><span class="line"><span class="regexp">  template:"&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/</span>p&gt;<span class="string">"</span></span><br><span class="line"><span class="string">  data: () &#123;</span></span><br><span class="line"><span class="string">    return&#123;</span></span><br><span class="line"><span class="string">      text:'我开我家'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">new author().$mount('#author')</span></span><br><span class="line"><span class="string">new author().$mount('author')</span></span><br><span class="line"><span class="string">//建议使用id的方式</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>全局数据操作vue.set()<br>vue.set()的作用就是在构造器外部操作构造器内部的数据。然而有很多的方法也可以完成在构造器外部操作内部数据，但是对于数组的index和长度的变化vue是监听不到的，也就是说通过数组下标或者长度来改变数组的值，vue是监听不到数据变化的，数据没有变化虚拟dom也不会进行渲染。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id = <span class="string">"app"</span>&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button onclick = 'add'&gt;&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function add() &#123;</span></span><br><span class="line"><span class="regexp">    app.data[1] = "fff"    /</span><span class="regexp">/不会更新arr的数据，导致不会触发vue渲染</span></span><br><span class="line"><span class="regexp">    Vue.set(app.arr,1,'dd') /</span><span class="regexp">/可以更新arr中的数据，会出府啊vue的渲染</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">var app = new vue(</span></span><br><span class="line"><span class="regexp">  &#123;</span></span><br><span class="line"><span class="regexp"> data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: "ok"</span></span><br><span class="line"><span class="regexp">      data:['aaa','bbb','ccc']</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>template模板（有三种模板形式）</p>
<ul>
<li><p>1、在实例构造器中最常见的（适用于内容比较少的模板）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">'app'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">      message:'这是模板一'</span></span><br><span class="line"><span class="regexp">    &#125;，</span></span><br><span class="line"><span class="regexp">    template: "&lt;p&gt;这是模板一&lt;/</span>p&gt;<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>2、 在dom中写模板，挂在到实例构造器中（这种方法适用于模板内容比较大的情况）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">'#app'</span>&gt;</span><br><span class="line">  &lt;template id=<span class="string">'tep'</span>&gt;</span><br><span class="line">    &lt;p&gt;这是使用方法二&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  var app = new Vue (&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    tepmplate: '#tep'</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、新建一个script标签，并在标签内部进行修改（这种方法适用于从外部引入大段模板）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">'x-template'</span> id=<span class="string">"add3"</span> src=<span class="string">''</span>&gt;</span><br><span class="line">  &lt;p&gt;我是第三中方法&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    template: <span class="string">"#add3"</span></span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定义全局组件vue.componment()</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">'x-template'</span> id=<span class="string">"add3"</span> src=<span class="string">''</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">add</span>&gt;</span><span class="tag">&lt;/<span class="name">add</span>&gt;</span></span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Vue.componment(<span class="string">'add'</span>,&#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;我爱我家&lt;/h1&gt;'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><ul>
<li>全局扩展传参（propsDate）</li>
<li>计算选项  （computed）</li>
<li>方法选项  （method）</li>
<li>监听数据选项  （watch）</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>轮播插件之无缝轮播失效解决方案</title>
    <url>/2020/03/31/%E8%BD%AE%E6%92%AD%E6%8F%92%E4%BB%B6%E4%B9%8B%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/f6d31e2732e0" target="_blank" rel="noopener">参考</a><br>产生无缝轮播失效的原因<br>：是因为swiper提前初始化了，那时候数据还没有完全出来</p>
<ul>
<li><ol>
<li>使用vue提供的$nextTick()方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">var</span> swiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">		此处省略</span><br><span class="line">         &#125;）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>2、在swiper初始化的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">swiper1 = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">    initialSlide :<span class="number">0</span>,</span><br><span class="line">    observer:<span class="literal">true</span>,<span class="comment">//修改swiper自己或子元素时，自动初始化swiper</span></span><br><span class="line">    observeParents:<span class="literal">true</span><span class="comment">//修改swiper的父元素时，自动初始化swiper</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>路由守卫</title>
    <url>/2020/03/28/%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h1 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h1><a id="more"></a>
<p>老规矩先去刷一遍<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">官网</a></p>
<ul>
<li>1、全局前置守卫beforEach<blockquote>
<p>router.beforeEach((to, from, next) =&gt; {})</p>
</blockquote>
</li>
<li>2、全局解析守卫beforeResolve<blockquote>
<p>router.beforeRsolve((to, from, next) =&gt; {})</p>
</blockquote>
</li>
<li>3、全局后置钩子afterEach（少用）<blockquote>
<p>router.afterEach((to, from) =&gt; {}）</p>
</blockquote>
</li>
<li>4、路由独享的守卫<blockquote>
<p>直接在路由配置上定义beforEach</p>
</blockquote>
</li>
<li>5、组件内的守卫<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate</li>
<li>beforeRouteLeave</li>
</ul>
</li>
<li>6、路由导航解析<ul>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>axios基本操作</title>
    <url>/2020/03/27/axios%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="axios基本操作"><a href="#axios基本操作" class="headerlink" title="axios基本操作"></a>axios基本操作</h1><a id="more"></a>

<p>开始学习前一定要先去<a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">官网</a>看一看，太详细了。</p>
<h1 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a>什么是axios</h1><pre><code>Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中。vue-resource在2.5版本后官方就不在维护，并推荐大家使用Axios</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>1、请求</li>
</ul>
<p>post请求（通过配置请求，直接请求）<br>get请求  （通过配置请求，直接请求）<br>默认请求 （Axios默认发送get请求）<br>多并发请求</p>
<ul>
<li><p>1、 迭代请求</p>
</li>
<li><p>2、 等待请求</p>
</li>
<li><p>2、配置</p>
</li>
<li><p>请求配置（发送前需要配置的内容）</p>
</li>
<li><p>响应结构（响应后返回的数据）</p>
</li>
<li><p>默认配置</p>
</li>
<li><p>1、全局默认值（moudle文件中已经配置好了，有修改需求才修改）</p>
</li>
<li><p>2、自定义默认值（自己创建的axios实例需要配置，不配置就会延用默认配置）</p>
</li>
<li><p>3、拦截器（会在请求响应被then，catch处理前拦截它们）</p>
</li>
<li><p>1、请求拦截器</p>
</li>
<li><p>2、响应拦截器</p>
</li>
<li><p>3、拦截器的移出</p>
</li>
<li><p>4、创建实例</p>
</li>
<li><p>建议创建实例来进行代码编写（原因：通过axios直接绑定都会直接绑定到全局上面，这样就会有一个累计拦截的问题，每次请求服务器的时候都会触发一次axios拦截，但是如果使用实例那么对应实例的多次拦截次数并不会增加。也就是说直接使用axios拦截几次就是几次，使用实例每个实例都只算一次拦截）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex解析</title>
    <url>/2020/03/26/vuex%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="vuex基本使用"><a href="#vuex基本使用" class="headerlink" title="vuex基本使用"></a>vuex基本使用</h1><a id="more"></a>
<p>建议先去看一下<a href="https://www.jianshu.com/p/2e5973fe1223" target="_blank" rel="noopener">简书</a>中下大概介绍。下面就是一个大概的总结。</p>
<ul>
<li><p>vuex的组成部分</p>
<ul>
<li>1、state：数据存储（类似与vue中的data）</li>
<li>2、mutations：对state中数据的操作（类似于vue中的method）</li>
<li>3、getters：加工state中的数据返回给外界（类似于compute计算属性）</li>
<li>4、actions：可以处理异步的方法，mutations只可以处理同步的方法</li>
<li>5、modules：vuex模块化</li>
</ul>
</li>
<li><p>1.1、vuex初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建VueX对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.2、vuex挂载到vue实例中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,  <span class="comment">//store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这一步挂载到实例中，会挂载到根vue上，在其他组件中不需要引入就可以之间通过 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.name (+对应的数据)</span><br></pre></td></tr></table></figure>
<p>的方法获取vuex中的数据</p>
</li>
</ul>
<hr>
<hr>
<hr>
<h2 id="内容的基本使用"><a href="#内容的基本使用" class="headerlink" title="内容的基本使用"></a>内容的基本使用</h2><ul>
<li>1.1、Mutations基本配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">    <span class="comment">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class="line">    edit(state,payload)&#123;</span><br><span class="line">        <span class="comment">//state state对象</span></span><br><span class="line">        <span class="comment">//payload 方法调用的时候传递的参数是一个对象&#123;&#125;</span></span><br><span class="line">        state.name = <span class="string">'jack'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>1.2、Mutations的调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过这个就可以调用对应的方法，修改state中的数据</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<hr>
<ul>
<li>2.1、Getters</li>
</ul>
<p>可以对state中的成员加工后传递给外界</p>
<ul>
<li><p>Getters中的方法有两个默认参数</p>
<ul>
<li>1、state 当前VueX对象中的状态对象</li>
<li>2、getters 当前getters对象，用于将getters下的其他getter拿来用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    nameInfo(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名:"</span>+state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    fullInfo(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.nameInfo+<span class="string">'年龄:'</span>+state.age</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
组件中调用<blockquote>
<p>this.$store.getters.fullInfo</p>
</blockquote>
</li>
</ul>
</li>
<li><p>3、 Actions</p>
</li>
</ul>
<p>由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。</p>
<ul>
<li><p>Actions中的方法有两个默认参数</p>
<ul>
<li>1、context 上下文(相当于箭头函数中的this)对象</li>
<li>2、payload 挂载参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    aEdit(context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
组件调用<blockquote>
<p>this.$store.dispatch(‘aEdit’,{age:15})</p>
</blockquote>
</li>
</ul>
</li>
<li><p>4、 Models<br>模块目前还没有用过可以先看看<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">官网</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基础操作</title>
    <url>/2020/03/24/webpack%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="webpack基础操作"><a href="#webpack基础操作" class="headerlink" title="webpack基础操作"></a>webpack基础操作</h1><a id="more"></a>
<h2 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h2><ul>
<li><p>全局安装</p>
<blockquote>
<p>npm i -g webpack</p>
</blockquote>
</li>
<li><p>打包</p>
</li>
</ul>
<blockquote>
<p>方法一 ：webpack main.js bundle.js(第一个为入口文件，编译后形成的文件)</p>
</blockquote>
<p>再把打包后的文件bundle.js引入到html中</p>
<blockquote>
<p>方法二：在根目录下加入webpack.config.js文件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry : main.js,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname,<span class="string">"./dist/"</span>),  <span class="comment">//必须时绝对路径</span></span><br><span class="line">        filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在终端中输入webpack就可以了，webpack时基于node环境的，所以可以之接引入path。</p>
<hr>
<ul>
<li>局部安装(推荐使用)<blockquote>
<p>npm i -D webpack   //安装</p>
</blockquote>
</li>
</ul>
<p>安装完成后需要对npm script进行配置（也就是在package。json文件中的scripts属性中进行配置）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">    bundle: 'webpack',   //默认会去node_modules中的找webpack</span><br><span class="line">    自定义名： ‘文件地址’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行npm run bundle<br>本地安装的必须配置到npm scritps中才可以使用</p>
</blockquote>
<hr>
<ul>
<li>总结</li>
</ul>
<p>全局安装webpack一般会在测试的时候使用，因为全局安装时在你的电脑上安装webpack，如果把项目发给其他人，他的电脑上面的webpack版本与你的不一致那么就会出现编译错误或无法编译。</p>
<p>局部安装会安装到你的项目中，及时把项目发送给其他人，项目编译也会去找项目中的webpack，这样就不会出现版本不同而导致的无法编译的问题。</p>
<p>为了划分目录清晰我们对项目做以下划分</p>
<ul>
<li>把源码存储到src文件夹中</li>
<li>把打包的结果存在dist文件夹中</li>
</ul>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="Es6模块规范"><a href="#Es6模块规范" class="headerlink" title="Es6模块规范"></a>Es6模块规范</h1><ul>
<li><p>默认导入导出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 导出</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            aa: <span class="number">5</span>,</span><br><span class="line">            bb: <span class="number">8</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#导入</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line">这种引入方式只会引入默认的内容（也就是<span class="keyword">export</span> <span class="keyword">default</span> 中的内容）</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通导入导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">'哈哈'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">'喜喜'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">"path"</span></span><br><span class="line">这种的导出方式，导入需要先结构，结构完成后的 a === 导出中的a</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>1、默认导入导出与普通的导入导出之间的存在是互不影响的。</li>
</ul>
<hr>
<hr>
<hr>
<hr>
<h1 id="css的打包"><a href="#css的打包" class="headerlink" title="css的打包"></a>css的打包</h1><ul>
<li>1、首先需要安装两个包<blockquote>
<p>npm i -D css-loader style-loader</p>
</blockquote>
</li>
<li>2、配置（找到webpack的配置文件）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#在最下面输入</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            text: <span class="regexp">/.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">'style.loader'</span>,  <span class="comment">//这个包会在html文件中的head部分插入一个style并把css的文件自动引入</span></span><br><span class="line">                <span class="string">'css-loader'</span>   <span class="comment">//这个包会把css文件转化为js文件</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、配置完成后据可以使用<blockquote>
<p>npm run build  //打包</p>
</blockquote>
</li>
</ul>
<h1 id="图片打包"><a href="#图片打包" class="headerlink" title="图片打包"></a>图片打包</h1><p>安装插件</p>
<blockquote>
<p>npm install –save-dev file-loader<br>安装完成后，取药去weback.config文件中进行配置<br>在rules中加个对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#123;</span><br><span class="line">    test: &#x2F;.(jpg|png|gif|svg)$&#x2F;,</span><br><span class="line">    use: [  </span><br><span class="line">        &#39;filer-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会把图片打包到dist文件夹中，但是这是你使用浏览器打开的时候控制台会报错，没有找到图片。这是因为打包好的图片贺html文件不在同一个地方，他找不到。解决方法：把html文件也自动打包到dist文件夹中</p>
<h1 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h1><p>会把源码的html文件打包到dist文件中。会自动引入html需要的图片。</p>
<ul>
<li>安装依赖<blockquote>
<p>npm install –save-dev html-webpack-plugin</p>
</blockquote>
</li>
<li>配置</li>
</ul>
<p>在webpack配置文件中加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先在全局中引入  webpack-olugin</span><br><span class="line">const htmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line">在moudle上面添加</span><br><span class="line">plugins: [</span><br><span class="line">    new htmlWebpackPlugin(&#123;</span><br><span class="line">        template: &#39;.&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="less打包"><a href="#less打包" class="headerlink" title="less打包"></a>less打包</h1><ul>
<li>安装依赖<blockquote>
<p>npm install -D less less-loader</p>
</blockquote>
</li>
</ul>
</li>
<li><p>配置</p>
</li>
</ul>
<p>在webpack配置文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在rulers中进行配置</span><br><span class="line">&#123;</span><br><span class="line">    test: &#x2F;.less$&#x2F;,</span><br><span class="line">    use: [</span><br><span class="line">        &#39;style-loader&#39;,</span><br><span class="line">        &#39;css-loader&#39;,</span><br><span class="line">        &#39;less-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p>会在自动根据代码完成情况来自动打包，不需要写一下就要打包一下</p>
<ul>
<li>安装依赖<blockquote>
<p>npm install –save-dev webpack-dev-server</p>
</blockquote>
</li>
<li>配置</li>
</ul>
<p>在webpack配置文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: &#39;.&#x2F;dist&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后需要去webpack.json文件中的script中配置</p>
<blockquote>
<p>‘dev’: ‘webpack-dev-server –open’</p>
</blockquote>
<h1 id="bable-loader"><a href="#bable-loader" class="headerlink" title="bable-loader"></a>bable-loader</h1><p>es6转码器，bable打包编译很慢，需要在webpack.config文件中的bable配置规则中配置打包缓存，属性cacheDirectory：true</p>
<h1 id="bable-polyfill"><a href="#bable-polyfill" class="headerlink" title="bable-polyfill"></a>bable-polyfill</h1><p>用于提供低版本浏览器不支持的api</p>
<h1 id="tansfrom-runtime"><a href="#tansfrom-runtime" class="headerlink" title="tansfrom-runtime"></a>tansfrom-runtime</h1><p>解决代码重复问题，需要在webpack.config文件中的bable配置规则中配置打包缓存，属性plugins：【tansfrom-runtime】</p>
<h1 id="vue-Loader"><a href="#vue-Loader" class="headerlink" title="vue Loader"></a>vue Loader</h1><p>处理打包单文件组件vue的打包问题，包括css，es6等。需要依赖vue-template-loader</p>
]]></content>
  </entry>
  <entry>
    <title>“css sticky footer</title>
    <url>/2020/03/22/%E2%80%9Ccss-sticky-footer/</url>
    <content><![CDATA[<h1 id="CSS经典布局之Sticky-footer布局"><a href="#CSS经典布局之Sticky-footer布局" class="headerlink" title="CSS经典布局之Sticky footer布局"></a>CSS经典布局之Sticky footer布局</h1><a id="more"></a>
<p>我们常见的网页布局方式一般分为header（页头）部分,content（内容区）部分和footer（页脚）部分。当页头区和内容区的内容较少时，页脚区不是随着内容区排布而是始终显示在屏幕的最下方。当内容区的内容较多时，页脚能随着文档流撑开始终显示在页面的最下方。这就是传说中的Sticky footer布局。</p>
<ul>
<li>负margin布局方式</li>
</ul>
<p>html模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是头部<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 2017 No rights reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Made with ♥ by an anonymous pastafarian.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.detail</span>&#123;</span><br><span class="line">     <span class="attribute">position</span>:fixed;</span><br><span class="line">     <span class="attribute">overflow</span>:auto;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">     <span class="attribute">min-height</span>:<span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.title</span> <span class="selector-tag">h1</span>&#123;</span><br><span class="line">     <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">     <span class="attribute">margin-top</span>:<span class="number">64px</span>;</span><br><span class="line">     <span class="attribute">padding-bottom</span>:<span class="number">64px</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.main</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">25px</span>; </span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">     <span class="attribute">margin</span>:-<span class="number">64px</span> auto <span class="number">0</span> auto;</span><br><span class="line">     <span class="attribute">font-size</span>:<span class="number">32px</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: block;</span><br><span class="line">     <span class="attribute">content</span>: <span class="string">"."</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">clear</span>: both;</span><br><span class="line">     <span class="attribute">visibility</span>: hidden;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>main里面padding-bottom的值与footer中的负margin值要保持一直</p>
</blockquote>
<ul>
<li>flex布局方式</li>
</ul>
<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Site name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 2017 No rights reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Made with ♥ by an anonymous pastafarian.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-tag">body</span>&#123;<span class="attribute">display</span>: flex; <span class="attribute">flex-flow</span>: column; <span class="attribute">min-height</span>: <span class="number">100vh</span>; <span class="attribute">overflow</span>:auto;&#125;</span><br><span class="line"> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>: <span class="number">60px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line"> <span class="selector-tag">p</span>&#123;<span class="attribute">font-size</span>: <span class="number">24px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;<span class="attribute">flex</span>:<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>flex布局结构简单，代码精简。因为flex存在着兼容性，所以在使用这种方式布局时需要注意。</p>
</blockquote>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>路由模块化</title>
    <url>/2020/03/21/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="路由模块化"><a href="#路由模块化" class="headerlink" title="路由模块化"></a>路由模块化</h1><p>平时我们使用路由都是这样子的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">"/login"</span><span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;&#125;)</span><br><span class="line">app.get(<span class="string">"/regirse"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>如果要配置子路由那么有需要这样一条一条的来写，那么现在我们使用了模块化之后，就会非常方便。</p>
<blockquote>
<p>创建一个文件夹 mode.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> routers = express.Router()</span><br><span class="line">routers.get(<span class="string">"/good"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">routers.get(<span class="string">"/send"</span><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  app.use(<span class="string">"/api"</span> routers)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>canvas基础教程</title>
    <url>/2020/03/18/canvas%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="canvas基础教程"><a href="#canvas基础教程" class="headerlink" title="canvas基础教程"></a>canvas基础教程</h1><a id="more"></a>
<p>canvas是H5新增的一个绘制标签，display是line类型。控制他的大小需要把盒子类型设置为display：block。之后就可以设置自己画布的大小（canvas画布的大小），绘制过程在js部分进行。</p>
<hr>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><ul>
<li>1、获取对应canvas标签<blockquote>
<p>let canvas = document.getElementById(“canvas”)</p>
</blockquote>
</li>
<li>2、创建画笔<blockquote>
<p>let cxt = canvas.getContext(“2d”)  //这里也可以写3d</p>
</blockquote>
</li>
<li>3、设置画笔样式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cxt.lineJoin = round/beter<span class="string">""</span> 线段闭合处边角</span><br><span class="line">cxt.strokeStyl<span class="string">""</span>设置画笔颜色，</span><br><span class="line">cxt.lineWidth=<span class="string">""</span>设置画笔粗细</span><br><span class="line"></span><br><span class="line">ctx.lineCap=<span class="string">"round"</span>一条线段的两端样式  两端边圆角，两端增加现款一半</span><br></pre></td></tr></table></figure></li>
<li>4、习惯<br>每次重新绘制图形的时候一定要使用<br>beginPath来把每个图像进行隔离<br>cxt.closePath()把路径合并<br>cxt.beginPath()开始绘制一个路径</li>
</ul>
<hr>
<h2 id="第二部"><a href="#第二部" class="headerlink" title="第二部"></a>第二部</h2><pre><code>这里我们就可以进行绘制图像</code></pre><hr>
<ul>
<li>1、绘制长方形</li>
</ul>
<p>方法一<br>创建绘制计划</p>
<blockquote>
<p>canvas.rect(x,y,w,h)</p>
</blockquote>
<p>x：起始点横坐标坐标<br>y：起始点纵坐标<br>w：矩形宽度<br>h：矩形高度</p>
<p>开始绘制</p>
<blockquote>
<p>cxt.fill()    //绘制实心的矩形</p>
</blockquote>
<blockquote>
<p>cxt.stroke()   //绘制空心的矩形</p>
</blockquote>
<p>这里有还有另一种绘制的方法，绘制计划与执行一起</p>
<blockquote>
<p>cxt.fillRect(x,y,w,h)//绘制实心矩形</p>
</blockquote>
<blockquote>
<p>cxt.strokeRect(x,y,w,h)//绘制空心矩形</p>
</blockquote>
<hr>
<ul>
<li>2、绘制圆形<blockquote>
<p>cxt.arc(x,y,r,regb,rege,driction)//指定画园计划</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>cxt.fill()绘制实心园</p>
</blockquote>
<blockquote>
<p>cxt.stroke()绘制空心园</p>
</blockquote>
<p>x:起始点<br>y:起始点<br>r：圆的半径<br>regb：开始角度<br>rege：结束角度<br>driction：画原方向（默认false）</p>
<ul>
<li>3、绘制文字<blockquote>
<p>cxt.fillText(“content”,x,y)//绘制实心文字</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>cxt.strokeText(“content”,x,y)//绘制空心文字</p>
</blockquote>
<p>content：文字内容<br>x：起始点横坐标<br>y：起始点纵坐标</p>
<ul>
<li>4、绘制文字的样式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cxt.font(字体大小,字体类型)</span><br><span class="line">cxt.textAlign = <span class="string">"center"</span>文字居中对齐</span><br><span class="line">cxt.Baseline = <span class="string">"center"</span>基线对齐</span><br><span class="line">cxt.shadowffsetx=<span class="number">10</span></span><br><span class="line">cxt.shadowColor = <span class="string">""</span></span><br></pre></td></tr></table></figure></li>
<li>5、渐变</li>
</ul>
<p>线性渐变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   color = cxt.createLinearGradient()</span><br><span class="line">color.addColorStop(<span class="number">0</span>,red)    </span><br><span class="line">   color.addColorStop(<span class="number">1</span>,bule)</span><br><span class="line">cxt.fillStyle = color</span><br><span class="line">画笔使用color配置的颜色</span><br></pre></td></tr></table></figure>

<p>径向渐变</p>
<blockquote>
<p>color =cxt.createRadialGradient(圆形坐标x，y，r，x，y，r)</p>
</blockquote>
<ul>
<li>绘制线段<br>cxt.moveTo(起始点的x，y)<br>cxt.lineTo（中止点的x，y）<br>cxt.stroke()</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>node中神奇的包-bcryptjs加密解密</title>
    <url>/2020/03/18/node%E4%B8%AD%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8C%85-bcryptjs%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="node中神奇的包-bcryptjs加密解密"><a href="#node中神奇的包-bcryptjs加密解密" class="headerlink" title="node中神奇的包-bcryptjs加密解密"></a>node中神奇的包-bcryptjs加密解密</h1><ul>
<li>什么是bcrypyjs？<blockquote>
<p>bcryptjs是一个第三方密码加密库，是对原有的bcrypt的优化，优点是不需要安装任何依赖</p>
</blockquote>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000008841988" target="_blank" rel="noopener">具体使用可以看看这里</a></p>
<ul>
<li>下面我们来讲讲文档上面没有的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//salt是设置加密的强度 最高好像就是10</span></span><br><span class="line"><span class="keyword">var</span> salt = bcrypt.genSaltSync(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<a href="https://segmentfault.com/a/1190000013165651" target="_blank" rel="noopener">基本运行原理可以点击这里</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mongoose的基本使用</title>
    <url>/2020/03/18/mongoose%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="mongoose的基本使用"><a href="#mongoose的基本使用" class="headerlink" title="mongoose的基本使用"></a>mongoose的基本使用</h1><a id="more"></a>

<ul>
<li>在开始之前，没有什么比先去官网刷一遍更有用的了<a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">mongoose官网</a></li>
</ul>
<blockquote>
<p>mongoose 是什么？他有什么用呢？</p>
</blockquote>
<blockquote>
<p>mongoose 是操作 MongoDB 的一个对象模型库；它封装了MongoDB对文档操作的常用处理方法（增删改查），让 NodeJS 操作 Mongodb 数据库变得快捷灵活。</p>
</blockquote>
<ul>
<li>下面我们来看看这个例子</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/test"</span>);</span><br><span class="line"><span class="comment">// var testModel = db.model('test1', testSchema); // 集合名称；集合的结构对象</span></span><br><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> TestModel = db.model(<span class="string">"test1"</span>, TestSchema );</span><br><span class="line"><span class="keyword">var</span> TestEntity = <span class="keyword">new</span> TestModel(&#123;</span><br><span class="line">    name : <span class="string">"helloworld"</span>,</span><br><span class="line">    age  : <span class="number">28</span>,</span><br><span class="line">    email: <span class="string">"helloworld@qq.com"</span></span><br><span class="line">&#125;);</span><br><span class="line">TestEntity.save(<span class="function"><span class="keyword">function</span>(<span class="params">error,doc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"error :"</span> + error);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力，因为mongodb不具备sql数据库的那种紧密的关系同时我们需要保证数据的完整性，因此我们需要制定一个规则骨架来约束用户。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Model ： 由 Schema 发布生成的模型，具有抽象属性和行为的数据库操作(也就是说把框架转化为一个可以使用的模型)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TestModel = db.model(<span class="string">"test1"</span>, TestSchema );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Entity ： 由 Model 创建的实体，他的操作也会影响数据库</p>
</blockquote>
<ul>
<li>那么Model和Entity有什么区别呢？三者又有什么关系呢？<blockquote>
<p>Model 与 Entity没有什么区别，唯一区别就是使用的操作型上面。Model 和 Entity 都可对数据库操作造成影响，但 Model 比Entity 更具操作性。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Schema 生成 Model，Model创造 Entity;</p>
</blockquote>
<hr>
<h2 id="Model-数据插入"><a href="#Model-数据插入" class="headerlink" title="Model 数据插入"></a>Model 数据插入</h2><hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">  age: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  email: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">  time: &#123;<span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> testModel = db.model(<span class="string">'test1'</span>, testSchema); <span class="comment">// 集合名称；集合的结构对象</span></span><br><span class="line"><span class="comment">// Document文档（关联数组式的对象） &lt; Collection集合 &lt; 数据库</span></span><br><span class="line"><span class="comment">// 插入保存一段数据</span></span><br><span class="line">testModel.create([</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test1"</span>, <span class="attr">age</span>: <span class="number">8</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test2"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test3"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test4"</span>, <span class="attr">age</span>: <span class="number">38</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test5"</span>, <span class="attr">age</span>: <span class="number">48</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test6"</span>, <span class="attr">age</span>: <span class="number">58</span>, <span class="attr">email</span>:<span class="string">"tttt@qq.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test7"</span>, <span class="attr">age</span>: <span class="number">68</span>, <span class="attr">email</span>:<span class="string">"ssss@qq.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test8"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test9"</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">email</span>:<span class="string">"rrrr@qq.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test10"</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">error, docs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'save ok'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>find数据查询<blockquote>
<p>mongoose 提供了find、findOne、和findById方法用于文档查询。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model.find(Conditions,fields,options,callback(err, doc));</span><br><span class="line">model.find(&#123;<span class="string">"name"</span>:<span class="string">"zs"</span>&#125;,callback(err, doc));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Conditions: 查询条件<br>fields: 返回的字段<br>options: 游标（sort,limit）<br>callback: 回调函数，参数doc为查询出来的结果</p>
</blockquote>
<ul>
<li><p>update 数据更新</p>
<blockquote>
<p>基本使用：model.update(查询条件,更新对象,callback);<br>model.findByIdAndUpdate(id,更新的内容,callback)</p>
</blockquote>
</li>
<li><p>remove 删除数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本使用：</span></span><br><span class="line"><span class="comment">//删除查询到的所有数据</span></span><br><span class="line">model.remove(查询条件,callback);</span><br><span class="line"><span class="comment">//删除查询到的一条数据</span></span><br><span class="line">model.findOneAndRemove(查询条件，callback)</span><br><span class="line">model.findByIdAndRemove(id，callback)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>express框架使用指南</title>
    <url>/2020/03/16/express%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="express框架使用指南"><a href="#express框架使用指南" class="headerlink" title="express框架使用指南"></a>express框架使用指南</h1><p><a href="http://expressjs.com/" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>
<ul>
<li>express介绍</li>
</ul>
<p>Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架<br>Express 框架是后台的 Node 框架，所以和 jQuery、zepto、yui、bootstrap<br>都不一个东西。<br>Express 在后台的受欢迎的程度类似前端的 jQuery，就是企业的事实上的标<br>准。</p>
<ul>
<li><p>express的特点</p>
<ul>
<li>Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供<br>系列强大的特性，帮助你创建各种 Web 和移动设备应用</li>
<li>丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友<br>好的 API 变得既快速又简单</li>
</ul>
</li>
<li><p>express的安装</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网： http:&#x2F;&#x2F;expressjs.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>  安装 Express 框架，就是使用 npm 的命令。（安装在需要使用express模板的文件夹）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure>

<p>  在完成上面安装的操作步骤后就可以使用express开发啦~</p>
</li>
</ul>
<ul>
<li>express的使用<br>  express有基本的识别能力，不需要自己添加contenttype/同时会内置处理没有配置的路径。相比于原生http的自己封装请求头，已经路由判断来说方便多了。<br>  0、配置公开资源目录(可以公开访问public下的所有文件)<blockquote>
<p>app.use(‘/public/‘,express.static(‘./public/‘))<br>  第一个public是别名,后面的是对应文件地址<br>  输入网址的时候例如<br><a href="http://www.localhost:3000/public/css/index.css" target="_blank" rel="noopener">http://www.localhost:3000/public/css/index.css</a><br>  还有第二种方式<br>app.use(express.static(‘./public/‘))<br>  这里输入网址的时候应该时这样<br><a href="http://www.localhost:3000/css/index.css" target="_blank" rel="noopener">http://www.localhost:3000/css/index.css</a><br>  不需要添加public</p>
</blockquote>
</li>
</ul>
<pre><code>0.1、修改代码自动重启
nodemon来解决修改代码重启的操作
&gt;npm install --global nodemon
启动文件的时候，使用nodemon启动就可以了
&gt;nodemon app.js
当文件变化时会自动帮你重启服务器

1、express的简单使用

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1、引入express到项目中 </span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2、实例一个对象 </span></span><br><span class="line"><span class="keyword">let</span> app = express() </span><br><span class="line"></span><br><span class="line"><span class="comment">//这里也可以在express前面加上一个new</span></span><br><span class="line"><span class="comment">//let app = new express()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;!-- 3、配置路由 --&gt;</span></span><br><span class="line">app.get(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req , res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"向前端发送的数据"</span>)</span><br><span class="line">    <span class="comment">//res.end("向前端发送的数据")</span></span><br><span class="line">    <span class="comment">//这里end 和 send 都可以向前台发送数据</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>)</span><br></pre></td></tr></table></figure>
上面这个例子是基于get传参的express框架的简单配值，配置完成后就可以在对应文件夹中打开终端输入```node 你的文件名.js ```就可以运行了。对于post传值我们下面会介绍到。
1.1、express中的res有多种方法
- send
` json 传入一个对象会默认把对象转换为json数据

2、动态路由

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1、引入express到项目中 </span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2、实例一个对象 </span></span><br><span class="line"><span class="keyword">let</span> app = express() </span><br><span class="line"></span><br><span class="line"><span class="comment">//这里配置的是二级动态路由</span></span><br><span class="line">app.get(<span class="string">"/news/:aid"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req , res</span>)</span>&#123;</span><br><span class="line">    req.params</span><br><span class="line">    <span class="comment">//req.params这个方法会得到动态路由的值</span></span><br><span class="line">    res.send(<span class="string">"向前端发送的数据"</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>)</span><br></pre></td></tr></table></figure>
在这个例子中大家可能不太懂这到底实在干什么那么，什么又是动态路由，下面我来给大家分析一下。

当我们在终端中运行node之后，通过浏览器打开 localhost/3000 就会弹出express运行的页面，当把网站变为localhost/news 就会进入到news的页面（news就是一级路由，在news后面二级路由以此类推） 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(/news/:路由的key)  key可以是任意单词，但是“：”不能省略</span></span><br><span class="line">app.get(<span class="string">"/news/:aid"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"动态路由"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
动态路由就是没有把路由地址写死，如上你可以在浏览器的news后面加上任意路由，页面都是可以进行访问的。但如果你写死了那么，你只能访问对应的路由，如果路由不匹配那么页面就会显示你访问的页面不存在。

2.1、路由重定向
&gt;res.redirect(&apos;/&apos;)
2.2、获取post传递数据
express中没有内置获取post请求体的api，我们需要结合第三方包
结合第三方插件  body-parser
&gt;npm install body-parser --save
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">/*引入*/</span> </span><br><span class="line"> <span class="keyword">var</span> body = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"> <span class="comment">//添加了这个配置后   req的请求对象中会多出来一个属性：body，我们可以通过这个body来获取表单的数据。</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 解析 application/json</span></span><br><span class="line">app.use(bodyParser.json()); </span><br><span class="line"><span class="comment">// 解析 application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;));</span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> express(); <span class="comment">/*实例化*/</span></span><br></pre></td></tr></table></figure>

2.3、以上都是非模块化的路由，如果你想让node模块化，你需要在根目录新建一个router.js，如下
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
express对象中有个router方法，用来存放你所配置的路由。
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'./router'</span>)</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure>



3、get传值

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">/*引入*/</span> </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> express(); <span class="comment">/*实例化*/</span> </span><br><span class="line">app.get(<span class="string">'/login?user="haha"&amp;password=123'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query)</span><br><span class="line">    <span class="comment">//req.query  这个方法会获得？后面的值，返回一个对象</span></span><br><span class="line">     res.send(<span class="string">'你好express'</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//res.send()  res.redirect()都会结束响应  与原生的write不同</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

4、express中使用ejs模板

&gt; 安装：</code></pre><p>npm install ejs –save</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置ejs模板引擎 */</span> </span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'ejs'</span>);</span><br><span class="line"> <span class="comment">//设置模板的位置 </span></span><br><span class="line"> app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);</span><br><span class="line"></span><br><span class="line"> app.get(<span class="string">"/news"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">     res.render(<span class="string">"index"</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//  这里与就是ejs中ejs.renderFile()一样</span></span><br><span class="line">    res.send(<span class="string">"ejs模板使用"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

5、中间件</code></pre><ul>
<li><p>应用级中间件</p>
<blockquote>
<p>在输入对应端口进入，对页面跳转进行拦截，根据回调函数来判断进入页面的条件，满足一定条件才可以进入页面（类似于vue中的路由守卫）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);<span class="comment">/*引入*/</span> </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> express(); <span class="comment">/*实例化*/</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()); next(); &#125;)</span><br></pre></td></tr></table></figure>
<p>只有这个中间件的回调函数中存在next（）方法的调用那么才可以继续继续跳转</p>
</li>
<li><p>路由中间件</p>
<blockquote>
<p>多个相同的路由地址，那么他会不会全部匹配呢，答案是否定的。他会匹配第一个设置的路由之后就不会在匹配其他相同的路由了。如果需要对应页面的数据/跳转的下一个一页面那么就需要在第一个路由中设置next（）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/news'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'新闻路由中间件通过app.use'</span>); </span><br><span class="line">     next();</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/news'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'新闻路由'</span>); </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误处理中间件</p>
<blockquote>
<p>就是通过应用中间件，对请求的状态进行判断，若状态码为404就会抛出对应信息。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123; res.status(<span class="number">404</span>).send(<span class="string">'这是404 表示路由没有匹配到'</span>) &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置中间件</p>
<blockquote>
<p>内置中间件用来托管静态页面</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>,express.static(__dirname+<span class="string">'/public'</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你输入static的路由会之间自动匹配到public文件夹中的内容</p>
</blockquote>
</li>
<li><p>第三方中间件</p>
<blockquote>
<p>body-parser ：解析body中的数据，并将其保存为Request对象的body属性。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>cookie-parser ：解析客户端cookie中的数据，并将其保存为Request对象的cookie属性</p>
</blockquote>
<blockquote>
<p>express-session ：解析服务端生成的sessionid对应的session数据，并将其保存为&gt;Request对象的session属性</p>
</blockquote>
<blockquote>
<p>query：这个中间件将一个查询字符串从URL转换为JS对象，并将其保存为Request对象的&gt;query属性。这个中间件在第四个版本中已经内置了无需安装。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置body-parser中间件 </span></span><br><span class="line"><span class="comment">// parse application /x-www-form-urlencoded </span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"><span class="comment">// parse application/json </span></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.post(<span class="string">"/login"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    req.body <span class="comment">//获得post传递过来的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>req.body就可以获得想要需要的数据，这些body的配置信息有什么用呢？</p>
<blockquote>
<p>bodyParser.json()  用来解析json格式的数据 本返回一个中间件到node中的applaction级<br>bodyParser.urlencoded()  用来解析表单格式的数据 本返回一个中间件到node中的applaction级<br><a href="https://www.jianshu.com/p/cd3de110b4b6" target="_blank" rel="noopener">详细介绍</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>解析node.js中的非阻塞Io</title>
    <url>/2020/03/16/0%E5%9F%BA%E7%A1%80%E8%A7%A3%E6%9E%90node-js/</url>
    <content><![CDATA[<h1 id="解析node-js中的非阻塞Io"><a href="#解析node-js中的非阻塞Io" class="headerlink" title="解析node.js中的非阻塞Io"></a>解析node.js中的非阻塞Io</h1><a id="more"></a>
<h2 id="io"><a href="#io" class="headerlink" title="io"></a>io</h2><p>1、首先什么是io？</p>
<ul>
<li>IO （计算机用语），io是计算机的一种硬件，主要用来处理数据的输入输出，I/O输入/输出(Input/Output)  ，I/O操作可以有多种方式，比如DIO(Direct I/O)，AIO(Asynchronous I/O，异步I/O)，Memory-Mapped I/O(内存映射I/O)等，不同的I/O方式有不同的实现方式和性能，在不同的应用中可以按情况选择不同的I/O方式。（这里的异步io不等于我们今天学习的非阻塞io）。</li>
</ul>
<p><a href="https://baike.baidu.com/item/IO/5918?fr=aladdin" target="_blank" rel="noopener">参考文档</a></p>
<p>2、io操作又是什么？</p>
<ul>
<li>说了一大堆到底什么是io操作呢？  通俗的来讲就是数据在计算机内部的输入与输出。例如：我们把io比作一个污水处理厂，污水的输入和清水的输出。并且io操作十分耗时，在阻塞io机制中，他需要等对应的数据内容读完后才会执行代码渲染，这个过程可能会消耗10s的事件。对于码农来说这已经是天文数字了。</li>
</ul>
<h2 id="Node中阻塞Io"><a href="#Node中阻塞Io" class="headerlink" title="Node中阻塞Io"></a>Node中阻塞Io</h2><p>1、什么是非阻塞io<br>非阻塞io是io数据处理方式的一种，这种处理方式不会导致进程的堵塞，类似与js中的异步。当碰到没有调用的程序他不会等这函数调用后在继续执行代码，而是跳过他执行下面的操作。那么万一在后面这个函数被调用了呢？那就是我要说的第二点。</p>
<p>2、非阻塞Io的运行原理</p>
<p>在跳过没有执行的函数后，自动的调用Node中的事件循环机制，不断的向刚才的那个没有调用的函数发起循环，你有没有被调用？如果没有过一会有再次询问，你有没有被调用，以此往复直到进程结束。如果在进程结束前他被调用了那么就会输出对应的数据。</p>
<p><img src="http://image.euphie.net/2017-09-24-23-19-53.png" alt=""><br><a href="https://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">参考文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
