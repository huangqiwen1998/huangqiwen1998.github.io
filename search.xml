<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>微信小程序Paused in Debugger</title>
    <url>/2020/05/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FPaused-in-Debugger/</url>
    <content><![CDATA[<h1 id="小程序使用observer监听事件后出现Pauser-in-Debugger"><a href="#小程序使用observer监听事件后出现Pauser-in-Debugger" class="headerlink" title="小程序使用observer监听事件后出现Pauser in Debugger"></a>小程序使用observer监听事件后出现Pauser in Debugger</h1><p>最新在再写音乐小程序的时候，通过监听歌曲id的变化，来切换歌曲。但是当我使用observer监听的时候出现了pauser in debugger</p>
<p>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component:&#123;</span><br><span class="line">    properties: &#123;</span><br><span class="line">    	songid: <span class="built_in">Number</span></span><br><span class="line">  	&#125;,</span><br><span class="line">    observers: &#123;</span><br><span class="line">    <span class="string">"songid"</span> : <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setDate(&#123;</span><br><span class="line">            <span class="keyword">this</span>.data.songid = id</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写会陷入死循环最后出现pauser in debugger的错误。因为observers是会监听songid的变化的，当监听到songid的变化就会触发对于的函数，修改songid的值。修改完成后observers再次监听到了songid的变化，再次触发对应的函数最后导致死循环。</p>
<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component:&#123;</span><br><span class="line">    properties: &#123;</span><br><span class="line">    	songid: <span class="built_in">Number</span></span><br><span class="line">  	&#125;,</span><br><span class="line">     data : &#123;</span><br><span class="line">         id : <span class="string">''</span></span><br><span class="line">     &#125;</span><br><span class="line">    observers: &#123;</span><br><span class="line">    <span class="string">"songid"</span> : <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setDate(&#123;</span><br><span class="line">            <span class="keyword">this</span>.data.id = id</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置一个中间的变量，用中间量去渲染对应的id，songid只用来监视用户是否切换了歌曲。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 4.0</title>
    <url>/2020/05/16/webpack-4-0/</url>
    <content><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h1 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h1><blockquote>
<p>npm install webpack webpack-cli -D</p>
</blockquote>
<h1 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h1><blockquote>
<p>npx webpack</p>
</blockquote>
<p>会去找到node_module中的webpack.cmd文件（如果当前目录下有就执行，没有就返回上一级目录找到webpack中的webpack.js）webpack.js文件会看你是否安装webpack cli，如果有就会提示你安装webpack cli。</p>
<h1 id="webpack-手动配置"><a href="#webpack-手动配置" class="headerlink" title="webpack 手动配置"></a>webpack 手动配置</h1><p>默认配置名字：webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,<span class="comment">//模式 默认两种 development production</span></span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 入口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>,<span class="comment">//打包后的文件名</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>)  <span class="comment">//路径  必须是绝对路径</span></span><br><span class="line">        publicPath:<span class="string">'http://www.hqwluck.xyz'</span><span class="comment">//配置公共引用资源路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动指定配置文件</p>
<blockquote>
<p>npx webpack –config webpack.config.js</p>
<p>npx webpack –config 配置文件名</p>
</blockquote>
<p>packjson中配置</p>
<p>在pack.json中的script添加一个”bulid”</p>
<blockquote>
<p>“bulid”: webpack –config webpack.config.js</p>
<p>“bulid”: webpack</p>
</blockquote>
<p>配置配置文件位置完成打包</p>
<blockquote>
<p>npm reun bulid – –config webpack.config.js</p>
<p>webpack中 – 后面的可以被当作参数进行操作</p>
<h1 id="webpack服务"><a href="#webpack服务" class="headerlink" title="webpack服务"></a>webpack服务</h1><p>使用npx开启服务</p>
<blockquote>
<p>npx webpack-dev-server</p>
</blockquote>
<p> 服务配置</p>
<p>在webpack.config.js文件中设置</p>
<blockquote>
<p>derSrever: {</p>
<p>port: 3000, //端口号</p>
<p>progress:true, //是否有进度条</p>
<p>contentBase:’./build’  默认开启服务的地址</p>
<p>}</p>
</blockquote>
<p>在pack.json文件中的script中添加</p>
<blockquote>
<p>“dev”: ‘’webpack-dev-serve’</p>
</blockquote>
</blockquote>
<h1 id="HTML插件"><a href="#HTML插件" class="headerlink" title="HTML插件"></a>HTML插件</h1><p>我们使用html-webpack-plugin插件，会把源码的html文件打包到dist文件中。会自动引入html需要的资源。</p>
<p>安装</p>
<blockquote>
<p>npm install html-webpack-plugin</p>
</blockquote>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./src/index.html'</span>，</span><br><span class="line">        filename:<span class="string">'index.html'</span>，</span><br><span class="line">        minify:&#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 去掉引号</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">//折叠空行</span></span><br><span class="line">    &#125;,</span><br><span class="line">        hash: ture</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>打包的时候为以templat的文件问模板在bulid文件中生成一个filename</p>
<h1 id="css插件（预处理）"><a href="#css插件（预处理）" class="headerlink" title="css插件（预处理）"></a>css插件（预处理）</h1><ul>
<li>loader(css-loader,style-loader,sass-loader)(style方式引入)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">moudle: &#123;</span><br><span class="line">    rules:[ <span class="comment">//规则</span></span><br><span class="line">        <span class="comment">//css-loader 解析@import这种语法</span></span><br><span class="line">        <span class="comment">//style-loader 把css插入head标签中</span></span><br><span class="line">        &#123;<span class="attr">test</span>: <span class="regexp">/\.css$/</span> , <span class="attr">user</span>:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] <span class="comment">//loader的顺序从右向左执行&#125;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mini-css-extract-plugin（link方式引入css）</li>
</ul>
<p>style-loader会把css样式插入head标签的style上但是代码过多就会很难看。因此我们使用mini-css-extract-plugin 把它用link标签引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugin:&#123;</span><br><span class="line">    <span class="keyword">new</span> MinCssExtractPlugin(&#123;</span><br><span class="line">        filename:<span class="string">'main.css'</span><span class="comment">//抽离出一个css文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">之后只需要用MinCssExtractPlugin.loader替换对应的style-loader就可以了。如果向抽离多个就创建多个之后只需要用MinCssExtractPlugin就可以了。</span><br></pre></td></tr></table></figure>



<ul>
<li><p>postcss-loader与autoprefixer(自动添加前缀)</p>
<p>首先新建一个文件postcss.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  只需要把postcss-loader放在css-loader之前就可以了。</p>
<h2 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h2><p>webpack默认打包js文件，对应css文件我们需要引入</p>
<p>optimize-css-assets-webpack-plugin</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization:&#123;<span class="comment">//优化项</span></span><br><span class="line">    minimizer:[</span><br><span class="line">        <span class="keyword">new</span> OptimizeCss()</span><br><span class="line">        如果设置了这个那么webpack中js压缩就会别清除，也就是说不会压缩。需要配合uglifyjs-webpack-plugin</span><br><span class="line">        <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        cache: <span class="literal">true</span>,</span><br><span class="line">        parallel:<span class="literal">true</span>,</span><br><span class="line">        sourceMap:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="js转化"><a href="#js转化" class="headerlink" title="js转化"></a>js转化</h1><h2 id="es6转es5"><a href="#es6转es5" class="headerlink" title="es6转es5"></a>es6转es5</h2><ul>
<li><p>bable-loader  es6&gt;es5格式转化</p>
</li>
<li><p>@bable/core </p>
</li>
<li><p>@bable/preset-env es6&gt;es5的模块语法转化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;<span class="attr">test</span>:<span class="string">'/\.js$/'</span>,<span class="attr">options</span>:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                <span class="string">'@bable/preset-env'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h1><p>webpack打包的时候，会把每个模块打包成一个闭包函数，从window上是访问不到的。我们可以使用以下方法。</p>
<ul>
<li><p>expose-loader   暴露   全局的loader   是内联loader</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：直接在引用的地方使用。（暴露在window）</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'expose-loader?$!jquery'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：在webpack.config.js文件中配置。</span></span><br><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),</span><br><span class="line">            use:<span class="string">'expose-loader?$'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：使用webpack在webpack.config.js文件中进行配置。每个文件都可以在上注入这个模块，但不能通过window获取。</span></span><br><span class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">        $:<span class="string">'jquery'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 方法四：通过在html页面使用cnd链接引入。暴露在window上</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>但是在生产环境下，我们不希望第三方插件也被打包。因此我们要使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">    jquery:<span class="string">'$'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图片打包"><a href="#图片打包" class="headerlink" title="图片打包"></a>图片打包</h1><p>file-loader:默认会在内部生成一张图片，到bulid目录下，把生成图片的名字返回(打包文件中js、css文件的图片都会默认的转换为生成图片的名字)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        test:<span class="string">'/\.(png|jpg|gif)$/'</span>,</span><br><span class="line">        loader:<span class="string">'file-loader'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>1、在js中创建图片来引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'./login'</span></span><br><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span>  Image()</span><br><span class="line">image.src = login</span><br><span class="line"><span class="built_in">document</span>.body.appendchild(image)</span><br></pre></td></tr></table></figure>
</li>
<li></li>
<li><p>2、css中backgorund-url</p>
</li>
<li><p>3、html页面中使用</p>
<p>这里我们需要一个插件html-withmig-loader会默认解析html中的图片文件，编译我们的文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="string">'/\.html$/'</span>,<span class="attr">use</span>:html-withimg-loader&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>图片比较小的时候，不希望发送http请求，我们把他转为base64的格式用url-loader。图片比较大的时候使用file-loader。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="string">'/\.(jpg|png|gif)$/'</span>&#125;,</span><br><span class="line">    use:&#123;</span><br><span class="line">    loader:<span class="string">'url-loader'</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">    limit:<span class="number">200</span>*<span class="number">1024</span>,  <span class="comment">//小于200k就转换为base64</span></span><br><span class="line">    outputPath:<span class="string">'/img/'</span>   <span class="comment">//配置图片打包路径</span></span><br><span class="line">    publicPath:<span class="string">'http:hqwluck.xyz'</span>  <span class="comment">//只会处理图片的应用路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h1 id="打包多页应用"><a href="#打包多页应用" class="headerlink" title="打包多页应用"></a>打包多页应用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span></span><br><span class="line">    <span class="comment">//多入口</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        home:<span class="string">'./src/index.js'</span>,</span><br><span class="line">        other:<span class="string">'./src/other.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:<span class="string">'./index.html'</span>,</span><br><span class="line">            filename:<span class="string">'home.html'</span></span><br><span class="line">            chunks:[<span class="string">'home'</span>]  <span class="comment">//指定引入的js  不写全引用</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:<span class="string">'./index.html'</span>,</span><br><span class="line">            filename:<span class="string">'other.html'</span></span><br><span class="line">            chunks:[<span class="string">'other'</span>]  <span class="comment">// 指定引入的js  不写全引用</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设置源码映射"><a href="#设置源码映射" class="headerlink" title="设置源码映射"></a>设置源码映射</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devtool:<span class="string">'source-map'</span>  <span class="comment">//增加映射文件  可以帮助我们调试源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、source-map   会标时当前报错的行列 （会创建一个映射文件）</span></span><br><span class="line"><span class="comment">2、eval-source-map 会产生行 列，不会创建一个映射文件。</span></span><br><span class="line"><span class="comment">3、cheap-moudle-source-map：不会产生列  但是是一个单独的映射文件</span></span><br><span class="line"><span class="comment">4、cheap-module-eval-source-map：不会生成文件，也没有列</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="实时打包"><a href="#实时打包" class="headerlink" title="实时打包"></a>实时打包</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: <span class="literal">true</span> <span class="comment">//监视代码 ， 代码有变化就会从新打包</span></span><br><span class="line">watchOptions:&#123;</span><br><span class="line">    <span class="comment">//监控的选项</span></span><br><span class="line">    poll: <span class="number">1000</span>, <span class="comment">//每秒 问我1000次</span></span><br><span class="line">	aggreateTime:<span class="number">500</span>     <span class="comment">//防抖的作用 500ms中停止数据才打包</span></span><br><span class="line">    ignored:<span class="string">'/node_modules'</span>  <span class="comment">//不监控那个文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="webpack小插件"><a href="#webpack小插件" class="headerlink" title="webpack小插件"></a>webpack小插件</h1><ul>
<li><p>CleanWebpackPlugin   clean-webpack-plugin</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin(<span class="string">'./dist'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>CopyWebpackPlugin     copy-webpack-plugin</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CopyWebpackPlugin([<span class="keyword">from</span>:<span class="string">'./doc'</span>,<span class="attr">to</span>:<span class="string">'./'</span>])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>bannerPlugin   banner-plugin 版权注释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'make 2020 by hqw'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="webpack配置跨域"><a href="#webpack配置跨域" class="headerlink" title="webpack配置跨域"></a>webpack配置跨域</h1><ul>
<li>1、通过服务端获取数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        <span class="string">'/api'</span>:<span class="string">'http://localhost:3000'</span>  <span class="comment">//配置一个代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    proxy:&#123;  重写</span><br><span class="line">		<span class="string">'/api'</span>:&#123;</span><br><span class="line">            target:<span class="string">'http://localhost:3000'</span>,</span><br><span class="line">            pathReWrite:&#123;<span class="string">"/api"</span>:<span class="string">""</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>2、mock数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    before(app)&#123;  <span class="comment">//这个app相当于express的实例app</span></span><br><span class="line">        app.get(<span class="string">'/user'</span>,(req , res) =&gt;&#123;</span><br><span class="line">            res.json(&#123;<span class="attr">name</span>:<span class="string">'hello word'</span>&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3、在服务端配置webpack（webpack与服务器同一端口）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="comment">//中间件</span></span><br><span class="line"><span class="keyword">let</span> middle = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"><span class="keyword">let</span> compiler = webpack(config)</span><br><span class="line">app.use(middle(compiler))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="resolve属性配置"><a href="#resolve属性配置" class="headerlink" title="resolve属性配置"></a>resolve属性配置</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve:&#123;  <span class="comment">//解析  第三方包的相关配置</span></span><br><span class="line">    <span class="built_in">module</span>:[path:resolve(<span class="string">'node_modules'</span>)] <span class="comment">//默认包查找位置，</span></span><br><span class="line">    mainFields:[<span class="string">'style'</span>,<span class="string">'main'</span>],</span><br><span class="line">    extensions:[<span class="string">'.js'</span>,<span class="string">'.css'</span>,<span class="string">'.json'</span>]</span><br><span class="line">    alias：&#123;<span class="comment">//别名</span></span><br><span class="line">        bootstrap: <span class="string">'bootstrap/dist/css/bootstrap.css'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h1><ul>
<li>noParse   不回去解析对应内容</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery/</span> ,<span class="comment">//不会区解析jequary 	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>webpack.IgnorePlugin()  忽略加载部分包</li>
<li>exclude: /node_module/   不去node_module中寻找</li>
<li>include:’path.resolve(‘src’)’ 只区src中寻找</li>
</ul>
<h1 id="多线程打包"><a href="#多线程打包" class="headerlink" title="多线程打包"></a>多线程打包</h1><p>一般项目很大的时候使用happypack</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> happypack = <span class="built_in">require</span>(happypack)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;<span class="attr">test</span>:<span class="string">'/\.js$/'</span>,<span class="attr">use</span>:<span class="string">'happypack/loader?id=js'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> Happypack(&#123;</span><br><span class="line">    id:<span class="string">'js'</span>,</span><br><span class="line">    use:[&#123;</span><br><span class="line">    	loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    	options:&#123;</span><br><span class="line">    		presets:[</span><br><span class="line">    			<span class="string">'@babel/preset-env'</span>,</span><br><span class="line">    			<span class="string">'@babel/preset-react'</span></span><br><span class="line">    ]	</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;]</span><br><span class="line">	&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数调用栈、递归优化</title>
    <url>/2020/05/16/js%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E3%80%81%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="什么是调用栈"><a href="#什么是调用栈" class="headerlink" title="什么是调用栈"></a>什么是调用栈</h1><p>JavaScript的V8引擎主要包括两个组件：内存堆、调用堆栈</p>
<p>内存堆：分为堆区和栈区，主要用来存放数据。</p>
<p>调用堆栈：这是在你代码执行时栈帧存放的位置</p>
<p>调用栈：就是调用堆栈、执行栈。</p>
<h1 id="什么是栈帧"><a href="#什么是栈帧" class="headerlink" title="什么是栈帧"></a>什么是栈帧</h1><p>调用栈的每个入口成为栈帧</p>
<p><img src="https://static.oschina.net/uploads/space/2017/1213/104147_KJwy_2896879.png" alt=""></p>
<p>每一个灰色的矩形就是一个栈帧。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>概念：一个函数调用自身。</p>
<p>特点：递归的效率不高，并且容易导致内存囤积从而导致内存泄漏。</p>
<p>原理：函数中调用自身，就会持续的不断的创建栈帧，然后压入栈顶，之前的那个栈帧就会被压入当前栈帧的下一层，一直递归导致栈被存满了，就会出现内存溢出。</p>
<p>基线条件：控制递归停止的条件</p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>概念：在函数的最后一步调用自身。</p>
<p>特点：只保存一个调用记录，所以不会发生栈溢出错误。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP</title>
    <url>/2020/05/15/PHP/</url>
    <content><![CDATA[<h1 id="数据表达"><a href="#数据表达" class="headerlink" title="数据表达"></a>数据表达</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><blockquote>
<p>语法：$变量名 = 值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$v1 = <span class="number">122</span>;</span><br><span class="line">$v2 = <span class="number">241</span>;</span><br><span class="line">$v3 = $v1 + $v2</span><br><span class="line">    </span><br><span class="line">echo $v3 <span class="comment">//输出变量$v3</span></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="判断变量-isset"><a href="#判断变量-isset" class="headerlink" title="判断变量(isset())"></a>判断变量(isset())</h3><p>判断一个变量名中是否存储了数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$v1 = <span class="number">122</span>;</span><br><span class="line">$v2 = <span class="number">241</span>;</span><br><span class="line">$result = isset($v2)</span><br><span class="line">echo $result <span class="comment">//变量中有值输出true   但是echo会有类型转换所以他会打印1</span></span><br><span class="line">var_dump($result) <span class="comment">// 不会类型转换打印true ， 可以输出一个变量的完整信息</span></span><br><span class="line"></span><br><span class="line">$v5 = <span class="literal">null</span> <span class="comment">//注意这里使用isset($v5)  &gt; 是没有值的</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>



<h3 id="销毁-删除变量-unset"><a href="#销毁-删除变量-unset" class="headerlink" title="销毁/删除变量(unset())"></a>销毁/删除变量(unset())</h3><p>当一个变量中存储了数据，我们也可以去销毁它</p>
<blockquote>
<p>unset($v1)</p>
</blockquote>
<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><ul>
<li>1、值传递</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$v1 = <span class="number">10</span></span><br><span class="line">$v3 = $v1   <span class="comment">//值的传递</span></span><br><span class="line"><span class="keyword">echo</span> $v3   <span class="comment">//10</span></span><br><span class="line">$v1 = <span class="number">11</span></span><br><span class="line"><span class="keyword">echo</span> $v3 <span class="comment">// 10</span></span><br><span class="line"><span class="comment">//值传递  传完后他们直接没有关系</span></span><br><span class="line">$v4 = $v1 + <span class="number">1</span> <span class="comment">//这不是传值</span></span><br></pre></td></tr></table></figure>

<p>会创建一个新的内存空间，来存储这个值</p>
<ul>
<li>2、引用传值</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$v1 = <span class="number">10</span>;</span><br><span class="line">$v2 = &amp;$v1   <span class="comment">//引用传值</span></span><br><span class="line"><span class="keyword">echo</span> $v2   <span class="comment">// 10</span></span><br><span class="line">$v1 = <span class="number">12</span> </span><br><span class="line"><span class="keyword">echo</span> $v2  <span class="comment">// 12</span></span><br><span class="line">$v2 = <span class="number">20</span> </span><br><span class="line"><span class="keyword">echo</span> $v1 <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>不会创建新的内存空间，他们共用同一个内存空间。</p>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>PHP语言内部，有一些变量，可以直接使用，这就是所谓的预定义变量。</p>
<ul>
<li><p>1、$_GET变量</p>
<p>代表浏览器表单通过‘get’方式提交的数据集合，可以称为get数据。</p>
<p>$_GET变量里面会自动存储提交到某个文件中的GET数据。</p>
<p>而GET数据是一个页面以‘get’方式请求时提交的数据。</p>
<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">from</span> <span class="attr">action</span> =<span class="string">'data.php'</span> <span class="attr">method</span> = <span class="string">'get'</span>&gt;</span></span><br><span class="line">    name:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">'text'</span> <span class="attr">name</span> = <span class="string">'username'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    age:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">'text'</span> <span class="attr">name</span> =<span class="string">'age'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'submit'</span> <span class="attr">value</span>=<span class="string">'提交'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$name = $_GET[<span class="string">'username'</span>]</span><br><span class="line">$age = $_GET[<span class="string">"age"</span>]</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'姓名'</span>$name</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'age'</span>$age</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>2、$_POST</p>
<p>会去post的相关的数据</p>
<p>简单的计算机案例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;php? </span><br><span class="line">    	$n1 = <span class="string">''</span></span><br><span class="line">    	$n2 = <span class="string">''</span></span><br><span class="line">    	$result = <span class="string">''</span></span><br><span class="line">    	<span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'num1'</span>]))&#123;</span><br><span class="line">            $n1 = $_POST[<span class="string">'num1'</span>])</span><br><span class="line">            $n2 = $_POST[<span class="string">'num2'</span>])</span><br><span class="line">            $result = $n1 + $n2</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">    &lt;from action =<span class="string">'data.php'</span> method = <span class="string">'post'</span>&gt;</span><br><span class="line">&lt;input type = <span class="string">'text'</span> name = <span class="string">'num1'</span> value=<span class="string">'&lt;?php echo $n1 ?&gt;'</span>/&gt;</span><br><span class="line">+</span><br><span class="line">&lt;input type = <span class="string">'text'</span> name =<span class="string">'num2'</span> value=<span class="string">'&lt;?php echo $n2 ?&gt;'</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">'submit'</span> value=<span class="string">'='</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">'text'</span> name=<span class="string">'result'</span> value=<span class="string">'&lt;?php echo $result ?&gt;'</span>&gt;</span><br><span class="line">&lt;/from&gt;</span><br><span class="line">    &lt;/body&gt;    </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、$_REQUERT</p>
<p>可以会去get和post请求的数据</p>
</li>
<li><p>4、$_SERVER变量</p>
<p>他会获取每一次请求中，客户端或服务器的一些基本信息，或系统信息。</p>
<p>PHP_SELF : 表示当前请求的网页地址(不包括域名)</p>
<p>SERVER_NAME:表示当前请求的服务器名</p>
<p>SERVER_ADDR:表示获取请求服务器的IP地址</p>
<p>REMOTE_ADDR: 表示当前请求的客户端IP地址</p>
<p>SCRIPT_NAME:表示获取当前网址</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">'你的IP为'</span>$_SERVER</span><br></pre></td></tr></table></figure>

<h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>含义：变量名本身又是一个变量</p>
<p>示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$v1 = <span class="number">10</span></span><br><span class="line">$str = v1</span><br><span class="line"><span class="keyword">echo</span> $$str <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="2-1常量的含义"><a href="#2-1常量的含义" class="headerlink" title="2.1常量的含义"></a>2.1常量的含义</h3><p>常量，就是一个用于存储’不会（也不允许变化的数据的标识符）‘</p>
<h3 id="2-2、常量的两种定义形式"><a href="#2-2、常量的两种定义形式" class="headerlink" title="2.2、常量的两种定义形式"></a>2.2、常量的两种定义形式</h3><ul>
<li><p>1、define()</p>
<blockquote>
<p>define(“name”,”value”)</p>
<p>define(‘PI1’,3)   //建议常量名字使用大写</p>
</blockquote>
</li>
<li><p>2、const PI2 = 3.14</p>
</li>
</ul>
<h3 id="2-3常量的取值"><a href="#2-3常量的取值" class="headerlink" title="2.3常量的取值"></a>2.3常量的取值</h3><ul>
<li>1、echo 常量名</li>
<li>2、echo constant（’常量名‘）</li>
</ul>
<h3 id="2-4、常量与变量的区别"><a href="#2-4、常量与变量的区别" class="headerlink" title="2.4、常量与变量的区别"></a>2.4、常量与变量的区别</h3><p>常量不能被重新赋值，已写好不得修改。</p>
<p>常量必须是固定值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5判断一个常量是否存在：defined"><a href="#2-5判断一个常量是否存在：defined" class="headerlink" title="2.5判断一个常量是否存在：defined()"></a>2.5判断一个常量是否存在：defined()</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!defined(<span class="string">'P1'</span>))&#123;</span><br><span class="line">    <span class="comment">///拿到别人的代码时候   判断常量P1是否被定义过</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-预定义常量"><a href="#2-6-预定义常量" class="headerlink" title="2.6 预定义常量"></a>2.6 预定义常量</h3><h3 id="2-7-魔术常量"><a href="#2-7-魔术常量" class="headerlink" title="2.7 魔术常量"></a>2.7 魔术常量</h3><p>是形式上的常量，他的值会根据网页不同，随时变化</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>整数类型：integer int</p>
<p>浮点数：double float    浮点数不要做相等比较，因为浮点数不可靠（计算机时二进制的小数转二进制时有很大问题的）</p>
<p>布尔型：boolean bool</p>
<p>字符串类型：string</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$v1 = <span class="number">10</span></span><br><span class="line">echo <span class="string">"&lt;br&gt;v1的值为:"</span> . $v1  <span class="comment">//10</span></span><br><span class="line">echo <span class="string">"&lt;br&gt;v1的值为 $v1"</span>   <span class="comment">//10</span></span><br><span class="line">echo <span class="string">'&lt;br&gt;v1的值为 $v1'</span>  <span class="comment">//$v1</span></span><br><span class="line">echo <span class="string">"&lt;br&gt;\$v1的值为 $v1"</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>



<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>1、数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$info2 = array(<span class="string">'name'</span>=&gt;<span class="string">'xiaoming'</span>,<span class="string">'age'</span>=&gt; <span class="number">18</span>) <span class="comment">//创建数组</span></span><br><span class="line">$info2 = [<span class="string">'name'</span>,<span class="string">'obj'</span>,<span class="string">'arr'</span>]</span><br><span class="line">$info3 = [<span class="string">'name'</span>=&gt;<span class="string">'xiamggg'</span>, <span class="string">'age'</span> =&gt; <span class="number">18</span>]</span><br><span class="line">$info2[<span class="string">'age'</span>] = <span class="number">19</span>  <span class="comment">//修改值</span></span><br><span class="line">print_r($info2) <span class="comment">//打印</span></span><br><span class="line">print_r($info2[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="空类型（null）"><a href="#空类型（null）" class="headerlink" title="空类型（null）"></a>空类型（null）</h3><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="gettype"><a href="#gettype" class="headerlink" title="gettype()"></a>gettype()</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$v1 = <span class="string">'str'</span></span><br><span class="line"><span class="keyword">echo</span> gettype($v1)  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">echo</span> settype($v1,integer)</span><br></pre></td></tr></table></figure>

<h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><p>is_int()</p>
<p>is_float()</p>
<p>is_bool)</p>
<p>is_string()</p>
<p>is_array()</p>
<p>is_object()</p>
<p>_is_numeric()   可以判断小数，整数，纯数字字符串</p>
<p>empty()判断变量是否为空</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>自动转换</p>
<p>所有算数运算符都会把字符串转换成数字类型</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转数字</span></span><br><span class="line"><span class="number">1</span> + <span class="string">'2'</span>  <span class="comment">// 3</span></span><br><span class="line"><span class="string">'1'</span>+<span class="string">'3'</span>  <span class="comment">// 4</span></span><br><span class="line"><span class="string">'1'</span>+ <span class="string">'2abc'</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">'1'</span>+ <span class="string">'2.2qab'</span> <span class="comment">//3.2</span></span><br><span class="line"><span class="number">1</span> . <span class="number">2</span> <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>强制转换</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$v1 = (int)<span class="string">'10'</span></span><br><span class="line"><span class="keyword">echo</span> $v1 <span class="comment">// 10</span></span><br><span class="line">$v2 = (float)<span class="string">'1.2'</span></span><br><span class="line"><span class="keyword">echo</span> $v2 <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure>

<h1 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h1><p>赋值运算符</p>
<p>算数运算符</p>
<p>连接运算符</p>
<p>自付值运算符</p>
<p>子操作运算符</p>
<p>比较运算符</p>
<p>逻辑运算符</p>
<p>条件运算符</p>
<p>按位运算符</p>
<p>错误抑制符</p>
]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>vue虚拟DOM解析</title>
    <url>/2020/05/14/vue%E8%99%9A%E6%8B%9FDOM%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1、什么是虚拟dom"><a href="#1、什么是虚拟dom" class="headerlink" title="1、什么是虚拟dom"></a>1、什么是虚拟dom</h1><p>Virtual DOM其实就是一颗以JavaScript对象作为基础的树，用对象属性来描述节点，实际就是真实dom的抽象。最终通过一系列操作使这课树映射到真实环境上。它描述了应该如何船舰一个真实的DOM节点。</p>
<h1 id="2、vue为什么使用虚拟dom"><a href="#2、vue为什么使用虚拟dom" class="headerlink" title="2、vue为什么使用虚拟dom"></a>2、vue为什么使用虚拟dom</h1><h2 id="创建真实DOM的代价高"><a href="#创建真实DOM的代价高" class="headerlink" title="创建真实DOM的代价高"></a>创建真实DOM的代价高</h2><p>真实的DOM节点（node）实现的属性很多，而虚拟节点（vnode）仅仅实现一些必要的属性，相比至下，创建一个vnode的成本低。不会覆盖，重绘，节点。他会找到真正有变化的节点对其进行修改。例如：一个ul标签下面有很多li标签，其中一个li编号，这种情况下如果使用新的ul替换旧的ul那么就会有不必要的浪费。</p>
<h1 id="3、vue中虚拟dom的实现过程"><a href="#3、vue中虚拟dom的实现过程" class="headerlink" title="3、vue中虚拟dom的实现过程"></a>3、vue中虚拟dom的实现过程</h1><h2 id="模板转视图的过程"><a href="#模板转视图的过程" class="headerlink" title="模板转视图的过程"></a>模板转视图的过程</h2><p>vue通过编译将template模板转换成渲染函数（render），执行渲染函数生成一个vnode（虚拟节点树）。又会通过patch函数对新旧虚拟DOM进行对比找出变化的节点，对齐进行修改。</p>
<p><img src="https://image.fundebug.com/2019-06-26-01.png" alt=""></p>
<p>对model进行操作的时候，会触发对应Dep中的watcher对象来修改视图，修改内容通过patch对比新旧vnode后的差距结果进行DOM渲染。</p>
<p><img src="https://image.fundebug.com/2019-06-26-02.png" alt="">))</p>
<h2 id="patch核心diff算法"><a href="#patch核心diff算法" class="headerlink" title="patch核心diff算法"></a>patch核心diff算法</h2><p><a href="https://blog.csdn.net/m6i37jk/article/details/78140159" target="_blank" rel="noopener">diff</a></p>
<p>diff值能在同层进行比较。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js垃圾回收机制</title>
    <url>/2020/05/11/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h1><h2 id="1、为什么会有垃圾回收机制。"><a href="#1、为什么会有垃圾回收机制。" class="headerlink" title="1、为什么会有垃圾回收机制。"></a>1、为什么会有垃圾回收机制。</h2><p>因为每次创建一个变量/函数都会占用内存，如果不清理内存都会导致内存泄漏。</p>
<h2 id="2、垃圾回收在什么时候执行。"><a href="#2、垃圾回收在什么时候执行。" class="headerlink" title="2、垃圾回收在什么时候执行。"></a>2、垃圾回收在什么时候执行。</h2><p>​    1、浏览器中会定时调用垃圾回收机制来清理全局执行上下文中标记为0或者值为undefined，null的变量（计数清除）。</p>
<p>​    2、当函数执行完毕后会清除所有被标记为离开环境的内容。</p>
<h2 id="3、垃圾回收机制执行的原理"><a href="#3、垃圾回收机制执行的原理" class="headerlink" title="3、垃圾回收机制执行的原理"></a>3、垃圾回收机制执行的原理</h2><ul>
<li>1、计数引用：当值被引用，那么他的引用次数就会加1.</li>
</ul>
<blockquote>
<p>var arr = [1,2,3]</p>
</blockquote>
<p>​            如上这个数组的引用次数就为1，再次引用就会依次叠加。</p>
<blockquote>
<p>var arr = null</p>
</blockquote>
<p>​            这是引用次数就为0，他就会被垃圾回收机制清除。</p>
<ul>
<li>2、标记清除：当全局执行上下文把权限下放到函数执行上下文时，会函数中的值进行标记（进入环境）。当函数执行完毕后执行上下文返还到全局的时候就会标记为（离开环境）所有有离开环境的值都会被清除。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  a = <span class="number">10</span>  <span class="comment">//标记‘进入环境’    </span></span><br><span class="line">    <span class="keyword">var</span>  b = <span class="string">'hollen word'</span>  <span class="comment">//标记‘进入环境’</span></span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//执行完毕后a b被标记为离开环境    垃圾回收机制清除内存。</span></span><br></pre></td></tr></table></figure>

<p>但是不会清理在执行环境变量中被执行中的环境调用的变量（闭包）</p>
<h2 id="WeakSet、WeakMap"><a href="#WeakSet、WeakMap" class="headerlink" title="WeakSet、WeakMap"></a>WeakSet、WeakMap</h2><p>这两种类型他们不会被计入垃圾回收机制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">a.set(b,<span class="string">'holle word'</span>) <span class="comment">//这里的b不会计入，也就是说new Object的计数值为1  而不是二。</span></span><br><span class="line">b = <span class="literal">null</span> <span class="comment">//这时计数为0</span></span><br><span class="line">a.get(b) <span class="comment">//找不到undefined  因为垃圾回收机制清理了内存，b也就消失了</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>apply bind call</title>
    <url>/2020/05/10/apply-bind-call/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2020/05/10/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>用户在规定时间间隔内持续完成一件事，不会触发函数执行。</p>
<h2 id="立即防抖"><a href="#立即防抖" class="headerlink" title="立即防抖"></a>立即防抖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func 执行的函数</span></span><br><span class="line"><span class="comment">// wait 延迟时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span>; <span class="comment">//没有任何效果只是一种习惯，js中的GC机制会把值为null，undefined的直接回收。</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数会先执行一次，之后在规定时间间隔内持续操作不会触发函数执行。</p>
<h2 id="非立即防抖"><a href="#非立即防抖" class="headerlink" title="非立即防抖"></a>非立即防抖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户在一定时间间隔内持续操作，不会触发函数。</p>
<h2 id="双剑合璧版"><a href="#双剑合璧版" class="headerlink" title="双剑合璧版"></a>双剑合璧版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>如果一个函数持续的，频繁的触发，那么就让他在一定的时间间隔后触发。</p>
<h2 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双剑合璧版-1"><a href="#双剑合璧版-1" class="headerlink" title="双剑合璧版"></a>双剑合璧版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* @desc 函数节流</span><br><span class="line">* @param func (<span class="function"><span class="keyword">function</span>) 函数</span></span><br><span class="line"><span class="function">* @<span class="title">param</span> <span class="title">wait</span> (<span class="params">number</span>) 延迟执行毫秒数</span></span><br><span class="line"><span class="function">* @<span class="title">param</span> <span class="title">type</span>  (<span class="params">number</span>) 1 表时间戳版，2 表定时器版</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">throttle</span>(<span class="params">func, wait ,type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type===<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(type===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type===<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span>;</span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>防抖：函数执行一次</p>
<p>节流：函数在一定时间内再次执行</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>node搭建接口</title>
    <url>/2020/05/08/node%E6%90%AD%E5%BB%BA%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="1、基本环境"><a href="#1、基本环境" class="headerlink" title="1、基本环境"></a>1、基本环境</h1><p>使用express mysql</p>
<ul>
<li><p>1、环境搭建</p>
<blockquote>
<p>node -v</p>
<p>npm -v</p>
<p>express -v</p>
</blockquote>
</li>
<li><p>2、创建express文件</p>
<blockquote>
<p>express apiLearn</p>
</blockquote>
</li>
</ul>
<p>创建完成后需要npm install安装依赖包，express默认的接口文件在bin目录中，但我们想要把入口文件设置成app.js</p>
<p>在app.js文件中写入以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app)</span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3、引入mysql包</p>
<blockquote>
<p>npm install mysql –save</p>
</blockquote>
</li>
<li><p>4、数据库连接池</p>
<ul>
<li><p>不使用连接池的时候：每次需要操作数据库的时候，系统底层会分配一个链接对象，你通过链接对象对数据库进行操作，当操作完成你会归还（释放）这个链接对象。下一次你需要操作数据库的时候你还需要系统给你一个链接对象，这样的操作过于繁琐，且消耗性能。</p>
</li>
<li><p>连接池：系统会自动创建一个池子，并且会给他分配多个链接对象，每次需要操作数据库时，就会从这个池中取出一个链接对象，去操作数据库，操作完成后链接对象会被归还到池子中。这样既实现了复用，同时也防止每次都向系统底层去请求链接对象，优化了性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports= &#123;</span><br><span class="line">    <span class="comment">//数据库配置</span></span><br><span class="line">    config:&#123;</span><br><span class="line">        host:<span class="string">"localhost"</span>,</span><br><span class="line">        port:<span class="string">'3306'</span>,</span><br><span class="line">        user:<span class="string">'root'</span>,</span><br><span class="line">        password:<span class="string">'root'</span>,</span><br><span class="line">        database:<span class="string">'express'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//链接数据库，使用mysql的连接池</span></span><br><span class="line">    <span class="comment">//连接池对象</span></span><br><span class="line">    sqlConnect: <span class="function"><span class="keyword">function</span>(<span class="params">sql,sqlArr,callBack</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pool = mysql.createPool(<span class="keyword">this</span>.config);</span><br><span class="line">        pool.getConnection(<span class="function">(<span class="params">err , conn</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1321</span>)</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'链接失败'</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//事件驱动回调</span></span><br><span class="line">            conn.query(sql,sqlArr,callBack);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放链接</span></span><br><span class="line">            conn.release()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用从新创建一个control的文件夹，写一个createcotrol.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">var</span> dbCongif = <span class="built_in">require</span>(<span class="string">'../until/dbConfig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取分类</span></span><br><span class="line">getCate = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sql = <span class="string">"select * from api"</span></span><br><span class="line">  <span class="keyword">var</span> sqlArr = [];</span><br><span class="line">  <span class="keyword">var</span> callBack = <span class="function">(<span class="params">err , data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'链接出错'</span>)</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        <span class="string">'list'</span> : data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dbCongif.sqlConnect(sql,sqlArr,callBack)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getCate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2、实现阿里大鱼短信服务"><a href="#2、实现阿里大鱼短信服务" class="headerlink" title="2、实现阿里大鱼短信服务"></a>2、实现阿里大鱼短信服务</h1><ul>
<li><p>1、登录阿里云，找到短信服务，编辑模板和标签，还需要开通短信服务。</p>
</li>
<li><p>2、配置短信服务运行环境</p>
<blockquote>
<p>npm install @alicloud/pop-core –save</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Core = <span class="built_in">require</span>(<span class="string">'@alicloud/pop-core'</span>);</span><br><span class="line"><span class="keyword">let</span> sendCoreCode = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> Core(&#123;</span><br><span class="line">  accessKeyId: <span class="string">'&lt;accessKeyId&gt;'</span>,</span><br><span class="line">  accessKeySecret: <span class="string">'&lt;accessSecret&gt;'</span>,</span><br><span class="line">  endpoint: <span class="string">'https://dysmsapi.aliyuncs.com'</span>,</span><br><span class="line">  apiVersion: <span class="string">'2017-05-25'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">  <span class="string">"RegionId"</span>: <span class="string">"cn-hangzhou"</span>,</span><br><span class="line">  <span class="string">"PhoneNumbers"</span>: <span class="string">"18180986281"</span>,</span><br><span class="line">  <span class="string">"SignName"</span>: <span class="string">"变美app"</span>,</span><br><span class="line">  <span class="string">"TemplateCode"</span>: <span class="string">"SMS_189713621"</span>,</span><br><span class="line">  <span class="string">"TemplateParam"</span>: <span class="string">"&#123;\"code\":\"code\"&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestOption = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.request(<span class="string">'SendSms'</span>, params, requestOption).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exprots = &#123;</span><br><span class="line">	sendCoreCode <span class="comment">//配置对应的路由上即可</span></span><br><span class="line">                                                      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、实现本地文件上传"><a href="#3、实现本地文件上传" class="headerlink" title="3、实现本地文件上传"></a>3、实现本地文件上传</h1><ul>
<li><p>multer这个第三方包可以用于，上传文件到数据库。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = multer.diskStorage(&#123;        <span class="comment">// 设置multer参数，个性化指定上传目录和文件名</span></span><br><span class="line">    destination: <span class="function">(<span class="params">req, file, cb</span>) =&gt;</span> &#123;		<span class="comment">//p配置文件上传地址</span></span><br><span class="line">        <span class="keyword">const</span> uploadFloder = <span class="string">'./myUpload'</span>;  <span class="comment">// 保存上传文件的目录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fs.accessSync(uploadFloder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            fs.mkdirSync(uploadFloder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cb(<span class="literal">null</span>, uploadFloder);</span><br><span class="line">    &#125;,</span><br><span class="line">    filename: <span class="function">(<span class="params">req, file, cb</span>) =&gt;</span> &#123;   <span class="comment">//配置文件名称</span></span><br><span class="line">        cb(<span class="literal">null</span>, file.originalname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123;                     <span class="comment">// 实例化multer对象</span></span><br><span class="line">    storage: storage</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态化资源</span></span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./view/index.html'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);  <span class="comment">// 进行上传操作的页面</span></span><br><span class="line"></span><br><span class="line">    res.send(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应上传请求</span></span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/upload'</span>, upload.single(<span class="string">'myFile'</span>), (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        message: <span class="string">'响应了请求'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'服务器已启动!'</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>探究现代web架构</title>
    <url>/2020/05/08/%E6%8E%A2%E7%A9%B6%E7%8E%B0%E4%BB%A3web%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1、单机架构"><a href="#1、单机架构" class="headerlink" title="1、单机架构"></a>1、单机架构</h1><ul>
<li>1、一个系统业务量很小的时候，所有代码都放在一个项目中，部署在一台服务器上</li>
<li>2、单机架构处理能力有限 》集群模式 》分布式 》 微服务</li>
<li>3、</li>
</ul>
<h2 id="1-1、虚拟主机"><a href="#1-1、虚拟主机" class="headerlink" title="1.1、虚拟主机"></a>1.1、虚拟主机</h2><ul>
<li><p>1、虚拟主机的原理：在服务器上给你划分一个目录给你的网站-</p>
</li>
<li><p>2、lls ：虚拟主机</p>
</li>
<li><p>3、vps：云服务器，阿里云</p>
</li>
<li><p>4、虚拟技术</p>
<ul>
<li>1、vpn：虚拟隧道</li>
<li>2、跳板：网络安全的范畴，特点难以追踪。</li>
</ul>
</li>
</ul>
<h2 id="1-2-、正向代理"><a href="#1-2-、正向代理" class="headerlink" title="1.2 、正向代理"></a>1.2 、正向代理</h2><ul>
<li>1、正向代理：类似于中介，所有的请求都会到达给中介，而不是直接传递给服务器。</li>
<li>2、基本原理：正向代理代理的是客户端，很多的客户端向同一个中介发送请求，中介向一台服务器发送请求。</li>
</ul>
<h2 id="1-3、反向代理"><a href="#1-3、反向代理" class="headerlink" title="1.3、反向代理"></a>1.3、反向代理</h2><ul>
<li>1、基本原理：反向代理代理的是服务器，一台客户端发送了一个请求，到代理服务器，代理服务器分配一个服务器给他。这个代理服务器会代理很多台服务器。（你不知道是那一台服务器与你的客户端相互交互）</li>
<li>2、优点：反向代理可以提高性能，因为反向代理后面有很多台服务器。</li>
</ul>
<h2 id="1-4、负载均衡"><a href="#1-4、负载均衡" class="headerlink" title="1.4、负载均衡"></a>1.4、负载均衡</h2><ul>
<li><p>1、没有负载均衡：通常单机架构会把文本服务器与数据库放在同一个服务器中。</p>
<ul>
<li>1、多个用户同时去访问我们的web服务器，超出我们服务器的处理能力时，响应速度慢，甚至会出现无法链接的情况</li>
<li>2、DDOS：拒绝服务式攻击。人为丶恶意制造，海量的数据在同一时间去访问我们的web服务器，人为让我们的服务器超过运算能力。</li>
<li>3、syns洪水攻击：针对tcp/ip的数据传输，让其半链接不断，并同时增加用户访问量。（拒接半链接的方式，硬件防火墙）</li>
<li>4、没有负载均衡：类似于学校选课的系统一样</li>
</ul>
</li>
<li><p>2、1个 负载均衡器，至少2个web服务器</p>
<ul>
<li>负载均衡器原理：会在用户与服务器之间建立一个负载均衡器，负载均衡器主要用于请求的分配，他会监控服务器的状态分配请求。</li>
</ul>
</li>
</ul>
<h1 id="2、集群"><a href="#2、集群" class="headerlink" title="2、集群"></a>2、集群</h1><ul>
<li>1、原理：将一个web应用程序，部署到多台服务器上，服务器的前面会有负载均衡器，负载均衡器来选择呢一台服务器去处理我们的请求。30台服务器，挂掉一台还有29台可以进行操作，不会影响我们的整个系统的正常运行</li>
<li>2、描述：一大群人做同一件事，一个人死了不影响。不用相互通讯。</li>
</ul>
<h1 id="3、分布式"><a href="#3、分布式" class="headerlink" title="3、分布式"></a>3、分布式</h1><ul>
<li>1、原理：分布式会把一个系统拆分成许多的模块，每一个模块对应一个服务器，服务器之间需要通讯。用户发送的请求会被负载均衡器来处理，然后根据请求访问不同的服务器类型，</li>
<li>2、描述：一大群人做自己不同的事情，他们会交流完成他们自己的事情。</li>
<li>3、通讯使用的技术：RPC  C/S webservice</li>
</ul>
<h1 id="4、中间层"><a href="#4、中间层" class="headerlink" title="4、中间层"></a>4、中间层</h1><ul>
<li>1、中间层：架构层面，中间件是一个函数。</li>
<li>2、mvc：后端提供接口，前端使用ajax调用接口，所有的渲染和数据都是由js在客户端生成的。<ul>
<li>SSR(服务端渲染)</li>
<li>CSR（客户端渲染）</li>
<li>渲染生成：生成html也页面的过程，可能造成首页白屏，同时也不利于SEO，SEO中有一个spider，这个spider对于静态页面非常友好，但是对于j非常不友好。</li>
</ul>
</li>
<li>3、我们使用中间层，后端只需要去关注接口，不需要去关注前端业务逻辑的实现。 </li>
<li>4、前端一般使用node作为中间层。</li>
</ul>
<h1 id="5、微服务"><a href="#5、微服务" class="headerlink" title="5、微服务"></a>5、微服务</h1><ul>
<li>1、原理：前端 + 中间层 完成前端所用的业务逻辑，后端只需要专注于接口的编写。</li>
<li>2、一般普通企业不会使用，里面的内容太过复杂</li>
</ul>
<h2 id="5-1-架构师于普通程序员的区别"><a href="#5-1-架构师于普通程序员的区别" class="headerlink" title="5.1 架构师于普通程序员的区别"></a>5.1 架构师于普通程序员的区别</h2><p>架构师：架构师脱离了业务层的，其实就是一种抽象。</p>
<p>程序原：代码和业务层高度相关的</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>node中间件</title>
    <url>/2020/05/03/node%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><a id="more"></a>
<p>中间件的本质就是一个请求处理方法，我们把用户从请求到响应dd 整个过程分发到多个中间件中去处理，这样有利于提高代码的灵活性，动态可扩展性。</p>
<ul>
<li><p>1、应用程序级别中间件</p>
<blockquote>
<p>万能匹配（不关心请求路径和请求方法的中间件，也就是说任何请求都会进入这个中间件。）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req , res , next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求进来了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以/xxx开头的路径中间件</span></span><br><span class="line">app.use(<span class="string">'/a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>2、路由中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req ,res</span>) </span>&#123;&#125;)</span><br><span class="line">app.post(<span class="string">'/'</span>)</span><br><span class="line">app.put()</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、第三方中间件<br>  body-parser</p>
</li>
<li><p>4、错误处理中间件<br>如果之前的中间件中err中传入了参数那么会直接找到错误处理中间件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err , req , res , next</span>)</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).json(&#123;</span><br><span class="line">        err_code : <span class="number">500</span>,</span><br><span class="line">        message : err.message</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie/session/token</title>
    <url>/2020/05/02/cookie%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="为什么需要cookie-session-token"><a href="#为什么需要cookie-session-token" class="headerlink" title="为什么需要cookie session token"></a>为什么需要cookie session token</h1><ul>
<li>1、http是无状态协议，他不会去记住或者认识是谁正在访问它，对于大型电商平台，需要区分每一个用户才可以把他们需要的东西加入他们的购物车。因此先辈们发明的cookie。</li>
<li>2、当用户访问了服务器，服务器就会生成一个cookie_id并传给浏览器保存，下一次访问服务器的时候就会携带这个cookie中有登录信息。传输给服务器后，服务器处理以下就可以判断区分用户了。但是cookie是保存在浏览器的那么就会有安全性问题。这是先辈们有引入了session。</li>
<li>3、每当用户与服务器建立一次链接就形成了session，这个session data会保存在服务器中，这个session记录着你的登录信息。同时还会生成一个session id 这个会被存放在浏览器的cookie中，等到下一次建立链接的时候会随着cookie被发送到服务端，服务端中就会将session_id 与session_data关联起来。区分用户，但是这种还是不够好，如果有负载均衡器那么与之链接的服务器可能是一个新的服务器，那么就无法建立链接，这时我们使用了token。</li>
<li>4、当用户与服务器建立链接服务器就会生成一个存放用户id的token返回给客户端的并存放在cookie，sessionstorage等中。当用户再次请求的时候，这个token就会被放在http header中。这个token可以在服务端进行一个签名，token会进行HMAC-SHA256算法，再加上一个只有我知道的密钥对数据进行一个签名。当token返回的时候我们就对token中的数据使用相同的HMAC-SHA256算法，在加上我们自己知道的密钥。两者进行对比如果相等就说明数据没有被更改过。</li>
</ul>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>http协议是一个无状态协议，他不会记录用户的信息。这是我们需要使用cookie来储存用户的信息。</p>
<ul>
<li>cookie中的信息是存储在浏览器中的，因此只能存储一些非铭感信息。</li>
</ul>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>为了解决cookie的问题，我们引入session。<br>超市   -   电子柜    -    消费者<br>电子柜（服务端）   给你一个凭证（cookie）凭证是唯一的，不可重复，一点丢失，不可找回。     你（客户端）<br>express-session这个插件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加session  </span></span><br><span class="line">req.session.user = user</span><br><span class="line"><span class="comment">//读取session</span></span><br><span class="line">req.session.user</span><br><span class="line"><span class="comment">//删除session</span></span><br><span class="line">req.session.user = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> req.session.user</span><br></pre></td></tr></table></figure>

<p>session：当有大量用户太消耗服务器的性能。</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>token的组成：</p>
<ul>
<li><p>1、header：在转为Base64编码</p>
<pre><code>- 1、类型：JWT
- 2、算法：HS256</code></pre></li>
<li><p>2、payload：会配置一些token的基本信息。在转为Base64编码</p>
</li>
<li><p>3、singnature：对 header + payload + 密钥 进行HS256算法加密，在转为Base64编码</p>
<p>token = header的Base64.payload的Base64.singnature的Base64</p>
</li>
</ul>
<p>完成上面3部分就生成了一个token了，这个token会被返回给客户端并保存，每次请求都会携带这个token，服务器对token中的header、payload进行转码，然后从新重复第三步，如果返回的结果与携带过来的一致，那么就认为用户已经登录了。</p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2020/04/30/promise/</url>
    <content><![CDATA[<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><a id="more"></a>
<h1 id="异步处理方式"><a href="#异步处理方式" class="headerlink" title="异步处理方式"></a>异步处理方式</h1><p>异步进程可以通过回调函数的形式来执行，如果需要控制异步程序执行的先后顺序那么就需用在异步函数的回调函数中套入另一个回调函数，如果异步程序比较多。这样就形成了回调地狱。</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>为了解决异步嵌套，es6中新增了一个api promise</p>
<h1 id="promise-1"><a href="#promise-1" class="headerlink" title="promise"></a>promise</h1><p>promise是一个异步容器,promise本身不是异步，只是用来存储异步进程</p>
<ul>
<li>1、基本使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建promise容器</span></span><br><span class="line"><span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2、解决回调地狱<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1 = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2 = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text1.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p3 = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./text.js'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p2    <span class="comment">//这里return可以呗后面的then接收/处理</span></span><br><span class="line">                    <span class="comment">//这里我们return一个promise对象同时可以被后面的then接受处理</span></span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p3</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;&#125; , <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
通过链式调用我们就可以解决异步程序先后执行顺序同时避免回调地狱的发送。但是上面的的代码有重复的东西，我们对他进行封装。新建一个js文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">pathfill</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">reslove , reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(pathfill,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样我们的代码就变得非常漂亮</li>
</ul>
<h1 id="promise使用场景"><a href="#promise使用场景" class="headerlink" title="promise使用场景"></a>promise使用场景</h1><p>promise是用来解决异步回调嵌套的问题，一般需要大量异步操作的地方都可以使用promise。例如 ajax数据请求，mongodb</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h1><blockquote>
<p>是一个符号，一个描述客观事物的符号，可以被计算机识别，并且输入给计算机处理的数据的一个符号集合（内存）</p>
</blockquote>
<h1 id="什么是数据元素"><a href="#什么是数据元素" class="headerlink" title="什么是数据元素"></a>什么是数据元素</h1><blockquote>
<p>由数据组成的有意义的集合体的基本单位    人   ，  摄影师   ， 老师</p>
</blockquote>
<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><blockquote>
<p>数据结构与计算机存储、组织数据的方式，精心选择的数据结构可以带来更高的运行或者存储效率。</p>
</blockquote>
<h1 id="由哪些数据结构"><a href="#由哪些数据结构" class="headerlink" title="由哪些数据结构"></a>由哪些数据结构</h1><ul>
<li><p>1、栈</p>
</li>
<li><p>2、堆</p>
</li>
<li><p>3、队列</p>
</li>
<li><p>4、数组</p>
</li>
<li><p>5、散列表</p>
</li>
<li><p>6、链表</p>
</li>
<li><p>7、图</p>
</li>
<li><p>8、树</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组是一串连续存储的数据，但是在js中的数组严格意义上来说不算是数组，他的存储方式与传统数组不同。</p>
</blockquote>
<blockquote>
<p>正真的数组他的删除和插入效率会很低，因为数组是一串连续存储的数据，为了保证他的连续他会自动的调整数据的位置以保证是连续存储</p>
</blockquote>
</li>
</ul>
<h1 id="1、栈与队列"><a href="#1、栈与队列" class="headerlink" title="1、栈与队列"></a>1、栈与队列</h1><p>栈是一种受限制的线性表，数据插入，删除，查找的时候不能随心所欲。(先进后后出，后进先出)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    push(ele)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出战</span></span><br><span class="line">    pop()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取栈顶元素</span></span><br><span class="line">    peek()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    isEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈的元素个数</span></span><br><span class="line">    size()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空栈</span></span><br><span class="line">    clean()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items == [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> stack()</span><br><span class="line">stack.push()</span><br><span class="line">stack.size()</span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转二进制</span></span><br><span class="line"><span class="keyword">const</span> binary = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = <span class="keyword">new</span> stack()</span><br><span class="line">    <span class="keyword">let</span> rem = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> _binary = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        rem = number % <span class="number">2</span>;</span><br><span class="line">        stack.push(rem);</span><br><span class="line">        number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        _binary += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _binary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binary(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<h2 id="1-1、js是单线程原理"><a href="#1-1、js是单线程原理" class="headerlink" title="1.1、js是单线程原理"></a>1.1、js是单线程原理</h2><ul>
<li><p>1、js为什么设计成单线程：两个人同时操作同一个dom这时不知道该听谁的。</p>
</li>
<li><p>2、js是单线程，浏览器是多进程的。</p>
</li>
<li><p>3、主线程自上而下，代码进栈、执行完毕后出栈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来1、2</span></span><br></pre></td></tr></table></figure></li>
<li><p>4、执行上下文：是当前js代码解析和执行所在的环境，所有的js代码都在执行上下文中去执行（执行环境）</p>
<ul>
<li>1、全局执行上下文：他是默认的也是最基础的执行上下文，任何函数都位于这个全局执行上下文。</li>
<li>2 、函数执行上下文：每次调用函数的时候，会为这个函数创建一个新的执行上下文。每个函数都有自己的函数执行上下文</li>
<li>3、eval函数执行上下文：理解为执行环境，如果你传入的是字符串并且js代码符合规范，那么这段js字符串会被执行。<br>这里我们对执行上下文与作用域来做个区别：</li>
<li>1、作用域：作用域是在函数定义的时候就已经定好了，可以理解为静态的。</li>
<li>2、执行上下文：是this的指向，this指向是谁调用就指向谁，也就是在执行上下文中执行谁，这个是动态的。<blockquote>
<p>当打开浏览器时js引擎会在执行栈中创建全局执行上下文，创建完成后开始从上至下执行js脚本中的代码，创建全局作用域，每当遇到函数调用就会创建函数执行上下文，并创建函数作用域，之后执行函数中的代码，当函数执行完毕后开始，会跳出函数的执行上下文，同时垃圾回收机制会清除局部作用域，之后把权限有再次交给全局执行上下文，依次执行代码直到代码执行完毕，这是全局执行上下文不会被消除（只有关闭浏览器才会消除），当浏览器关闭js引擎会触发垃圾回收机制清除执行栈中的函数声明，以及变量声明。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>5、js中的堆栈</p>
<ul>
<li>栈：一般用来存储基本数据类型，以及引用类型的内容地址。</li>
<li>堆：存放引用类型的内容，是真实的内存空间是开辟的。</li>
<li>执行栈：执行栈中会把js脚本非执行代码（也就是函数定义/变量定义入栈单不出栈，而对于执行的代码他们会依次入栈出栈，当js脚本中的代码执行完毕后，执行栈中就只剩下非执行代码了，那么这些代码会被垃圾回收机制清除，以保证下一次执行其他脚本时执行栈中执行上下文不会收到影响）中的所有代码一次</li>
</ul>
</li>
<li><p>6、作用域<br>  作用域</p>
<pre><code>- 1、词法作用域：也就是平时使用的作用域，全局作用域（GO）、函数作用域(AO)、会变量提升。</code></pre><ul>
<li>2、动态作用域：就是this对应的作用域，谁调用作用域就是谁。</li>
</ul>
</li>
</ul>
<h1 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h1><p>队列也是一种运算受限的线性表，先进先出</p>
<h2 id="2-1、js异步原理"><a href="#2-1、js异步原理" class="headerlink" title="2.1、js异步原理"></a>2.1、js异步原理</h2><ul>
<li>js中，维护这一个队列，这个队列叫做事件队列</li>
<li>javascript特点：单线程，同一个时间只能处理一件事<ul>
<li>JavaScript多线程原理：利用cpu的多核，h5提出了web worker的标准，允许js创建多个线程，而这些被创建的子线程是完全受到主线程控制的，并且子线程不可以操作dom，这个其实并没有改变js单线程的本质。</li>
</ul>
</li>
<li>线程：是操作系统能够进行运算调度的最小单位（对于操作系统来说，线程是最小执行单位，进程是最小资源管理单位）</li>
<li>进程与线程的区别：<ul>
<li>1、线程从属于进程。</li>
<li>2、每个开启一个程序进程就会在内存中开辟一块内存用来资源管理，线程就会执行里面的内容。</li>
<li>3、一个进程中可以有线程，一个主线程，还可以有多个子线程。</li>
<li>4、每个线程都会消耗内存。（node是单线程但是可以处理并发，因为他只有一个线程去处理多个线程的事情）</li>
</ul>
</li>
<li>js代码在引擎中执行的过程<ul>
<li>1、一开始会主线程会创建一个执行栈，在主线程外系统还会维护一个任务队列</li>
<li>2、所有同步代码都会被主线程放在执行栈中，异步代码都会被放入任务队列。</li>
<li>3、执行栈中对所有同步脚本代码执行完毕后，系统就会读取任务队列，并把任务队列读取到执行栈中执行，异步代码首先由结果就先输出谁，同等条件下根据队列的顺序一次输出（先进先出）</li>
<li>4、这里有个通知机制：当执行栈中的同步代码执行完毕后，任务队列会通知主线程，任务队列中的哪些资源已经准备好了，并按照谁先得到结果谁先输出的关系输出给执行栈。</li>
<li>5、事件循环：当主线程程序执行完毕，事件队列通知主线程读取任务队列的的过程叫做事件循环。</li>
</ul>
</li>
<li>promise<ul>
<li>1、任务队列中维护着两个任务队列，一个叫宏任务，一个叫微任务。<ul>
<li>宏任务：l/o 定时器/事件/Ajax</li>
<li>微任务：promise then finally,process async await</li>
</ul>
</li>
<li>2、js代码执行顺序：同步代码 &gt; 微任务 &gt; 宏任务</li>
</ul>
</li>
<li>node处理多并发优势<ul>
<li>java、php每一个客户请求，都会开一个新的线程，一个请求大概需要消耗2m的内存，8g最多是要4000和请求。</li>
<li>node不论你有多少线程，一个线程，事件驱动、非阻塞io，如果node主线程挂了，你的程序就挂了。</li>
</ul>
</li>
</ul>
<h1 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h1><ul>
<li>1、链表中的元素在内存中不必是连续的空间</li>
<li>2、链表每一个元素都由一个存储元素本身的节点和一个指向下一个元素的引用组成</li>
</ul>
<h2 id="1、JS中的堆栈"><a href="#1、JS中的堆栈" class="headerlink" title="1、JS中的堆栈"></a>1、JS中的堆栈</h2><ul>
<li>1、原始数据存储：<ul>
<li>1、首先将10存入栈空间（栈空间中开辟一个空间存入10）</li>
<li>2、定义一个变量a，此使a与变量是没有建立关系的，a的值为undefined</li>
<li>3、将变量a和值存储起来</li>
</ul>
</li>
<li>2、引用数据类型<ul>
<li>1、会在堆区开一一个空间存储值。</li>
<li>2、堆区会返回一个地址，对于这个地址先在栈区开辟一个空间。</li>
<li>3、定义一个变量fn，这个时候fn的值为undefined</li>
<li>4、将变量fn与地址存起来。</li>
</ul>
</li>
</ul>
<h2 id="2、链表的优势"><a href="#2、链表的优势" class="headerlink" title="2、链表的优势"></a>2、链表的优势</h2><ul>
<li>1、插入删除：链表的性能好</li>
<li>2、查找修改：数组性能好</li>
</ul>
<h2 id="3、链表的方法"><a href="#3、链表的方法" class="headerlink" title="3、链表的方法"></a>3、链表的方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    constructr(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkeedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    append(element)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">            <span class="keyword">while</span>(current.next)&#123;</span><br><span class="line">                current = current.next</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    insert(element , position)&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">let</span> privious = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">        <span class="keyword">if</span>(position &gt; <span class="number">0</span> || position &lt; <span class="keyword">this</span>.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">            node.next = current</span><br><span class="line">            <span class="keyword">this</span>.head = node</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; position)&#123;</span><br><span class="line">                privious = current</span><br><span class="line">                current = current.next</span><br><span class="line">                index++</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = current;</span><br><span class="line">            privious.next = node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取头节点</span></span><br><span class="line">    getHead()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">let</span> linkString = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            linkString += <span class="string">','</span> + current.element;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> linkString.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    remove(element)&#123;</span><br><span class="line">        <span class="keyword">let</span> privious = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">while</span>(current.next.element == element)&#123;</span><br><span class="line">            privious = current</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        privious.next == current.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    removeAt(position)&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">let</span> privious = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(position &gt; <span class="number">0</span> || position &lt; <span class="keyword">this</span>.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.head == <span class="literal">null</span> </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(index &lt;= position)&#123;</span><br><span class="line">                    privious = current</span><br><span class="line">                    current = current.next</span><br><span class="line">                    index++</span><br><span class="line">                &#125;</span><br><span class="line">                privious.next == current.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>1、append（element）：向链表尾部追加元素</li>
<li>2、insert（position,element）向例表中特定位置插入</li>
<li>3、remove（element）从例表中删除一项</li>
<li>4、indexof（element）返回元素的索引，如果例表中没有该元素测返回大于-1</li>
<li>5、removeAt（position）从例表中移出特定位置的一项</li>
<li>6、isEmpty（）：如果链表中不包含任何元素，返回true，如果链表长度大于0返回false。</li>
<li>size（）：返回链表包含元素的个数，于数组的length类似</li>
<li>toString（）：需要重写来继承JavaScript的方法</li>
</ul>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><ul>
<li>1、next直线下一个</li>
<li>2、prvies指向上一个</li>
<li>3、中间有个存储空间</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul>
<li><p>1、语言的发展</p>
<p>机器语言&gt;汇编语言&gt;低级语言&gt;高级语言</p>
</li>
<li><p>2、原型链的底层实现机制原理就是链表</p>
</li>
<li><p>3、<strong>proto</strong> 和constructor属性是对象独有的</p>
</li>
<li><p>4、prototype是函数独有的，函数也是一种对象所有有proto和constructor。</p>
</li>
<li><p>5、proto是隐式对象，一般不建议给隐式对象上面添加属性和方法。</p>
</li>
</ul>
<h1 id="4、集合"><a href="#4、集合" class="headerlink" title="4、集合"></a>4、集合</h1><p>集合通常是由一组无序的，不能重复的元素构成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> ()&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    has(val)&#123;</span><br><span class="line">        <span class="comment">// Object.hasOwnproperty(val)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item.hasOwnproperty(val)</span><br><span class="line">    &#125;</span><br><span class="line">    add(val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.has(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.item[val] = val</span><br><span class="line">    &#125;</span><br><span class="line">    remove(val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.has(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.item[val]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">	size()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.item).length</span><br><span class="line">    &#125;    </span><br><span class="line">    clear()&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    valuse()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//并集</span></span><br><span class="line">    union(<span class="keyword">set</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> unionSet = <span class="keyword">new</span> Myset()</span><br><span class="line">        <span class="keyword">let</span> valuse = <span class="keyword">this</span>.valuse()</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>,;i&lt; valuse.length; i++)&#123;</span><br><span class="line">            unionSet.add(valuse[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        valuse = <span class="keyword">set</span>.valuse();</span><br><span class="line">        for(let i = 0;i&lt;valuse.length; i++)&#123;</span><br><span class="line">            unionSet.add(valuese[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionSet</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交集</span></span><br><span class="line">    Intersection(<span class="keyword">set</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> intersection = <span class="keyword">new</span> Myset()</span><br><span class="line">        <span class="keyword">let</span> valuse = <span class="keyword">this</span>.valuse()</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;valuse.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">set</span>.has(valuse[i]))&#123;</span><br><span class="line">                intersection.add(valuse[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="js中的set、webset"><a href="#js中的set、webset" class="headerlink" title="js中的set、webset"></a>js中的set、webset</h2><ul>
<li>set：必须数组，里面不能有重复的内容。</li>
<li>webset：必须是对象，里面不能有重复的内容。是弱引用不会被垃圾回收机制录入</li>
</ul>
<h2 id="js中的map、weakmap"><a href="#js中的map、weakmap" class="headerlink" title="js中的map、weakmap"></a>js中的map、weakmap</h2><ul>
<li>map：普通对象的属性名只能是字符串，map属性可以是对象。</li>
<li>weakmap：只接受对象作为键名，null除外。</li>
</ul>
<h2 id="return拓展"><a href="#return拓展" class="headerlink" title="return拓展"></a>return拓展</h2><ul>
<li>return true：返还正确执行结果</li>
<li>return false：中止一些默认事件<ul>
<li>1、默认行为</li>
<li>2、组织冒泡</li>
<li>3、回调函数的执行</li>
</ul>
</li>
<li>return ： 返还控制权</li>
</ul>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>对象中的扩展运算符，用于取出对象中所有可遍历属性。一级属性浅拷贝，二级及其以上深拷贝。</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>复制一个对象和数组，但不可以改变原始数据类型</p>
<ul>
<li><p>js中的传值与传址：</p>
<p>传值：一般是原始数据类型使用，var a = 10 在这里会在栈空间中开辟一个空间存放10，然后在把a与10关联起来。var b = a 就会新开劈一块空间把a的值传进去，在于b相互关联。</p>
<p>传址：一般是引用数据类型，var a = {a:1} 会在堆区开辟一块内存存放，在把内存地址返回到栈区，栈区开一一块空间存储这个地址，再把地址与a进行关联。</p>
</li>
<li><p>原始数据类型没有深浅拷贝，深浅拷贝是针对于引用类型的。</p>
<ul>
<li>1、深拷贝：会重新创建内存空间，修改数据不会影响原有数据。</li>
<li>2、浅拷贝：不会创建新的空间，修改数据会影响原有数据。</li>
</ul>
</li>
<li><p>使用深浅拷贝使用场景：复制的数据类型的拷贝</p>
</li>
<li><p>拷贝方法：</p>
<ul>
<li>1、Object.assign()</li>
<li>2、遍历对象中的属性赋值给新对象</li>
<li>3、使用扩展运算符</li>
<li>4、JSON.parser(JSON.stringify(obj))  这种方法不会拷贝属性值为函数、undefined</li>
</ul>
</li>
<li><p>可以使用递归循环遍历对象：可以拷贝所有的属性以及值都是深拷贝。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li>内存泄漏：一块内存，既不能使用，也不能回收，直到浏览器结束。</li>
<li>内存堆积：最终会消耗尽系统的所有内存，导致浏览器崩溃。</li>
</ul>
</li>
</ul>
<h1 id="5、哈希表"><a href="#5、哈希表" class="headerlink" title="5、哈希表"></a>5、哈希表</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash：其实就是一种算法，把任意长度的输入通过散列算法变换成固定长度的输出，输出是散列值。hash和散列是同一个东西。</p>
<p>哈希算法不过是一个复杂的运算，他的输入可以是字符串，可以是任何文件，经过哈希运算以后，变成一个固定长度的输出，哈希算法有一个最大的特点：不可逆，不能从结果推算出输入。</p>
<p>hash是基于数组实现的，但是数组的插入删除效率不高，查询效率分两种（通过索引查找）效率高（通过内容查找）效率相对低。</p>
<h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><p>通过把散列函数把字符转为ascll对应的码值相加形成散列值，在通过散列值绘制散列表。散列表存储着所有的对于转换的码值。</p>
<p>hash函数</p>
<p>哈希函数就是把字符串转化为数字。</p>
<p>哈希函数有很多种，java hashcode 字符的acill码加在一起，然后在莫上一个质数，最后莫出多少就是多少，hash函数其实复杂的很，如何hash函数选的好的话，就可以让这些数字尽量避免去分散，而不会发送碰撞/冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = []; <span class="comment">//哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">    loseloseHashCode(key)&#123;</span><br><span class="line">        <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; key.length; i++)&#123;</span><br><span class="line">            hash += key[i].charCodeAt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//降低冲突，降低存储位数</span></span><br><span class="line">        <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    put(key , value)&#123;</span><br><span class="line">        <span class="keyword">const</span> position = <span class="keyword">this</span>.loseloseHashCode(key);</span><br><span class="line">        <span class="keyword">this</span>.table[position] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>(key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.table[<span class="keyword">this</span>.loseloseHashCode(key)];</span><br><span class="line">    &#125;</span><br><span class="line">    remove(key)&#123;</span><br><span class="line">        <span class="keyword">this</span>.table[<span class="keyword">this</span>.loseloseHeadCode(key)]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们使用了哈希函数处理，但是依然会发生碰撞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">money &gt; <span class="number">43</span>   oxgbx &gt; <span class="number">43</span></span><br></pre></td></tr></table></figure>

<p>解决冲突与碰撞（哈希覆盖）的方法</p>
<p>连地址法（拉链法）：哈希表种存储的不是一个实际的值，而是存储一个链表用来存储实际的值</p>
<p>开放地址法：寻找空白位置来放置数据（有三种放置方法）</p>
<ul>
<li>1、线性探测法：会从index + 1开始找，有空的就放进去，容易发生聚集，聚集会影响效率。</li>
<li>2、平方探测法：会从index+ 1 的平方开始，有空的就放进去，相比线性查找法减少了聚集的发生情况，但是会出现返回的情况，这也不利于哈希表的效率。</li>
<li>3、再哈希法：对数据再次使用hash算法，来制作hash表。</li>
</ul>
<h2 id="md5就是基于hash算法"><a href="#md5就是基于hash算法" class="headerlink" title="md5就是基于hash算法"></a>md5就是基于hash算法</h2><ul>
<li>1、特点：<ul>
<li>1、md5是一个不可逆的，加密（不算加密，加密应该有对于的解密）</li>
<li>2、计算极快</li>
</ul>
</li>
<li>2、md5的破解方法-&gt;撞库</li>
</ul>
<h2 id="哈希的两个特性"><a href="#哈希的两个特性" class="headerlink" title="哈希的两个特性"></a>哈希的两个特性</h2><p>1、不可逆</p>
<p>2、计算极快</p>
<h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p>编码其实就是把字符串转为计算机可以识别的数字。</p>
<p>通过下标查找速度很快》下标是数字》字符串数字》哈希函数》哈希碰撞？哈希覆盖》链地址法，开放地址法。hash缺点就是比较消耗内存。（以空间换时间）</p>
<h1 id="6、树"><a href="#6、树" class="headerlink" title="6、树"></a>6、树</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>树：n个节点构成的有限集合。</p>
<p>空树：n = 0（节点个数等于0）</p>
<p>根节点：n = 1（只有一个节点）</p>
<p>子树：以其他节点为根的树是子树。</p>
<p>节点的度：节点分支的个数。</p>
<p>树的度：选取所有节点种最大的度。</p>
<p>叶子节点：度为0的节点，位于树的最深层。</p>
<p>分支节点：度大于0的节点，除了叶子节点，其他的都是分支节点。</p>
<p>节点层次：是节点到根节点的边数。</p>
<p>树的深度：选取节点中最大的层次。</p>
<p>森林：所有子树的集合</p>
<h2 id="2、树的存储结构"><a href="#2、树的存储结构" class="headerlink" title="2、树的存储结构"></a>2、树的存储结构</h2><p>物理存储结构又2种，顺序存储和链式存储，因此树无法直接存储，所以要将树转化为顺序或者链式存储。</p>
<p>有三种方法：</p>
<ul>
<li>1、双亲表示法：采用顺序存储（数组）存储普通的树，顺序存储各个节点的同时，给各个节点添加父节点的位置的变量。<ul>
<li>优点：可以快速的获取任意节点的父节点的位置。</li>
<li>缺点：不能快速获取任意节点的子节点的位置</li>
</ul>
</li>
<li>2、孩子表示法：这一个方式，是创建多个指针域，指向它所有子节点的地址，也就是说任何一个节点都掌握着他的子节点的位置。</li>
<li>3、孩子兄弟表示法：这种方式会把一个树转化为二叉树，他的做法是；用两个指针分别指向它的第一个子节点和第一个右兄弟节点。</li>
</ul>
<h2 id="3、二叉树"><a href="#3、二叉树" class="headerlink" title="3、二叉树"></a>3、二叉树</h2><p>二叉树：最多只有2个节点。度不超过2的树</p>
<p>二叉树有五种形态：空树，只有一个根节点，只有一个左子树，只有一个右子树，两个节点都有。</p>
<p>第i层二叉树的最大节点数：2^(i-1)</p>
<ul>
<li><p>特殊的二叉树：</p>
<ul>
<li><p>1、满二叉树：树是满的，每个节点都有2个子节点。</p>
</li>
<li><p>2、完全二叉树：从根节点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子节点都靠左对齐。</p>
</li>
<li><p>3、二叉排序树、二叉搜索树、二叉查找树（BTS）：</p>
<p>非空左子树所有键值小于其根节点的键值</p>
<p>非空右子树所有键值大于其根节点的键值</p>
<p>左右子树本身也是二叉搜索树。</p>
</li>
</ul>
</li>
<li><p>二叉树的存储方式：数组、链表</p>
<ul>
<li>数组：不是很适合二叉树，使用数组存储二叉树必须满足是完全二叉树才可以。非完全二叉树他必须转成完全二叉树才可以存储。这样子就会有很大内存的浪费。因为转完全二叉树的时候空缺的位置都是null但是都分配了内存。</li>
<li>链表：最适合二叉树的存储方式，每个节点都封装成node，左节点的调用、右节点的调用。</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/jhzhahuaiyu/article/details/83143591?ops_request_misc=&request_id=&biz_id=102&utm_term=js递归&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-83143591" target="_blank" rel="noopener">https://blog.csdn.net/jhzhahuaiyu/article/details/83143591?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=js%E9%80%92%E5%BD%92&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-3-83143591</a></p>
<ul>
<li><p>平衡因子：左子树的高度减去右子树的高度，并且平衡因子的绝对值不能不大于1.</p>
</li>
<li><p>控制平衡因子的方法</p>
<ul>
<li>1、LL型（子节点向左）：左侧子节点的高度大于右侧子节点的高度（向右单旋转）</li>
<li>2、LR（向右双旋转）：这种情况，左侧子节点的高度大于右侧子节点的高度，并且左侧子节点的右侧较重</li>
<li>3、RR（向左单旋转）：右侧子节点的高度大于左侧子节点的高度</li>
<li>4、RL（向左双旋转）：右侧子节点的高度大于左侧子节点的高度，并且右侧子节点的左侧偏重。</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>特性：</p>
<ul>
<li>1、节点上是红色或者黑色。</li>
<li>2、根节点必须是黑色。</li>
<li>3、叶子节点（空节点）都是黑色，而且为nill</li>
<li>4、链接红色节点的两个子节点必须是黑色。</li>
<li>5、从任意节点出发，到每个叶子节点的路径中包含相同数量的黑色节点。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>node</title>
    <url>/2020/04/22/node/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="node-js是什么？"><a href="#node-js是什么？" class="headerlink" title="node.js是什么？"></a>node.js是什么？</h1><ul>
<li><p>node.js一个让javascript运行在服务端的开发平台</p>
<ul>
<li><p>node.js不是一门语言</p>
</li>
<li><p>node.js不是库，不是框架</p>
</li>
<li><p>node.js是一个JavaScript运行时环境</p>
</li>
<li><p>node.js是可以解析和执行js代码，以前只有浏览器可以解析JavaScript</p>
</li>
<li><p>也就是说有了node，JavaScript可以完全脱离浏览器运行。</p>
</li>
<li><p>构建与chrome的v8引擎上</p>
<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以识别他们，引擎会帮你去解析和执行</li>
<li>chrome的v8引擎，是目前公认执行js最快的引擎</li>
<li>node的作者把v8引擎提取出来，编译成了JavaScript的运行环境</li>
</ul>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>EcmaScript</li>
<li>Bom</li>
<li>Dom</li>
</ul>
</li>
<li><p>node中的JavaScript</p>
<ul>
<li>只有EcmaScript</li>
<li>没有Dom和Bom</li>
<li>node这个JavaScript运行时环境为JavaScript提供了一些服务器级别的操作API<ul>
<li>例如文件读写</li>
<li>网络服务的构建</li>
<li>网络通讯</li>
<li>http服务器等<ul>
<li>node.js使用机制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件驱动</p>
</li>
<li><p>非阻塞io模型，简单来说就是异步操作</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>node.js生态系统<ul>
<li>npm（世界上最大的开源库生态系统）</li>
<li>绝大数的JavaScript包都存放在npm上，让开发人员更方便的下载使用</li>
</ul>
</li>
</ul>
<h1 id="node-js能做什么？"><a href="#node-js能做什么？" class="headerlink" title="node.js能做什么？"></a>node.js能做什么？</h1><pre><code>- web服务器后台
- 命令行工具（npm，hexo）
- 一些资源
    - 《深入淡出Node.js》
    - 《node.js权威指南》</code></pre><h1 id="node-js学完能学到什么？"><a href="#node-js学完能学到什么？" class="headerlink" title="node.js学完能学到什么？"></a>node.js学完能学到什么？</h1><pre><code>- B/S编程模型
    - Brower-server
    - back-end
    - 任何服务端技术这种BS编译模型都是一样的，和语言无关

- 模块化编程
    - 通过commin.js导入导出对应模块
- 异步编程
    - 回调函数
    - promise
    - async
    - generator</code></pre><h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><pre><code>使用node编写应用程序主要就是在使用
    - ECMAscript
    - 核心模块
        - fs模块
        - http模块
        - url模块
    - 第三方模块
    - 自定义模块

- 1、什么是模块化
    - 文件作用域
    - 通讯规则




- commonJS模块规范
在node中的JavaScript还有一个跟重要的概念，模块系统
 - 模块作用域
 - 使用require方法来加载模块
 - 使用export 接口对象来导出模块中的成员

 - 加载 require
    两个作用
        - 执行被加载 模块的代码
        - 得到被加载模块中的exports导出接口对象
 - 导出 export
    - node中是模块作用域，默认文件中所有的成员只在当前文件模块有效
    - 对希望可以被其他模块访问的成员，我们需要把这些公开的成员挂在到exprots接口对象中就可以了
        - 导出多个成员
        <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span>.a = <span class="number">123</span></span><br><span class="line"><span class="keyword">export</span>.b = <span class="number">456</span></span><br><span class="line"><span class="keyword">export</span>.c=<span class="number">789</span></span><br></pre></td></tr></table></figure>
        - 导出单个成员
        <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="模块原理-接下来我们介绍一下原理"><a href="#模块原理-接下来我们介绍一下原理" class="headerlink" title="模块原理 接下来我们介绍一下原理"></a>模块原理 接下来我们介绍一下原理</h1><pre><code>这个原理有点像构造函数，node中只有模块作用.每个模板内部都有一个自己的对象module对象，在module对象中也有一个对象export的一个空对象。
默认在代码的最底层有一句话，return module.exports。而其中还有一局代码是var express = module.export  因此才有了export.a = 123这种导入。其实本质还是对module对象中的export导出。</code></pre><h1 id="模块查找机制"><a href="#模块查找机制" class="headerlink" title="模块查找机制"></a>模块查找机制</h1><h1 id="require-优先从缓存中加载"><a href="#require-优先从缓存中加载" class="headerlink" title="require  优先从缓存中加载"></a>require  优先从缓存中加载</h1><h1 id="标识符分析"><a href="#标识符分析" class="headerlink" title="标识符分析"></a>标识符分析</h1><pre><code>- 路径形式的模块
&gt;/(当前文件模块所属磁盘根路径)   ./   ../
- 核心模块
&gt;直接应用，这些核心文件已经被编译到二进制文件中了。
- 第三方模板
不可能有任何一个第三方包与核心模块的名字是一样的
&gt;先找到当前文件中的node_modules，你所引入的包/ 再去找到包中对应的pack.json文件/再去找到里面的main属性/main属性中就记录了当前包的入口模块。

&gt;如果pack.json不存在，并且main对应的路径是有问题的那么，那么pack.json文件在同一目录下的index.js文件      </code></pre><h1 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h1><pre><code>- 文件读取

    - fs.readFile(文件中存储的其实二进制0 1)</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/hello.text'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = data.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>    这里他呗默认转为了16进制，外面可以通过tostring方法转化成我们能认识的字符


- 写文件
    - fs.writeFile</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">'./data/holleword.text'</span>,<span class="string">"家好  我是holleword"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    <span class="comment">//没错error = null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h1><p>node可以非常轻松的构建一个web服务器，在node中提供一个核心模块：http</p>
<ul>
<li><p>1、加载http核心模块</p>
<blockquote>
<p>var http = require(‘http’)</p>
</blockquote>
</li>
<li><p>2、使用http.createServer（）方法创建一个web服务器，返回一个Server实例</p>
<blockquote>
<p>var server = http.createServer()</p>
</blockquote>
</li>
<li><p>3、服务器作用</p>
<p>  1、对数据提供服务</p>
<p>  2、发送请求</p>
<p>  3、接受数据</p>
<p>  4、处理请求</p>
<p>  5、响应请求</p>
<ul>
<li><p>配置头部信息</p>
<blockquote>
<p>res.setHeader(‘content-type’ , ‘text/plain’; charset=utf-8)</p>
</blockquote>
<p>  文件类型（content-type）</p>
<ul>
<li><p>非文字类型的都要把charset=utf-8去掉</p>
</li>
<li><p>text/plain 普通文本</p>
</li>
<li><p>text/html 就是html格式文本<br><a href="https://tool.oschina.net/" target="_blank" rel="noopener">工具</a><br>除了配置请求头中的content-type还可以在html页面的meta标签中声明他</p>
<p>文本编码格式</p>
<ul>
<li>在服务器默认发送的数据，默认都是utf8编码的内容</li>
<li>但是浏览器不知道你是什么类型的编码，你也没有告诉浏览器你发送的数据是什么编码</li>
<li>那么浏览器在不知道内容编码的情况下，默认按照当前操作系统的默认编码去解析</li>
<li>中文操作系统的默认编码格式是 gdk</li>
</ul>
</li>
</ul>
</li>
<li><p>监听request请求，当有客户端发送请求会自动执行request请求事件</p>
</li>
<li><p>服务端重定向</p>
<ul>
<li><p>以3开头的状态码都是用于重定向的。</p>
</li>
<li><p>首先设置状态码</p>
<blockquote>
<p>res.statusCode = 302</p>
</blockquote>
<p>301 永久重定向  浏览器会记住<br>302 零时重定向  浏览器记不住</p>
</li>
<li><p>配置重定向地址</p>
<blockquote>
<p>res.setHeader(‘Location’,’/‘)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'收到客户端请求'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求地址是'</span>+req.url)</span><br><span class="line">    <span class="comment">//req.url获取获取请求的url信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//res中有wrte方法，write可以多次使用但是最后必须使用end结束，如果不接受那么程序会继续等待</span></span><br><span class="line">    res.write(<span class="string">'holle'</span>)</span><br><span class="line">    res.write(<span class="string">'word'</span>)</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4、绑定端口号，启动服务器</p>
<blockquote>
<p>server.listen(3000)</p>
</blockquote>
</li>
<li><p>5、配置路由响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h1><p>用来帮你辅助操作路径的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取给定路径的文件名</span></span><br><span class="line">path.basename(<span class="string">'路径'</span>)   <span class="comment">//获取文件明年</span></span><br><span class="line">path.basename(<span class="string">'c/a/index.js'</span>)   <span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取给定路径的文件名</span></span><br><span class="line">path.dirname(<span class="string">'路径'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件扩展名</span></span><br><span class="line">path.extname(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为绝对路径</span></span><br><span class="line">path.isAbsolyte(path)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取分析路径中所有信息</span></span><br><span class="line">path.parse(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径拼接</span></span><br><span class="line">path.join(<span class="string">''</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="node中的其他成员"><a href="#node中的其他成员" class="headerlink" title="node中的其他成员"></a>node中的其他成员</h1><p>每个模块中，除了require、exports等模块，还有两个特殊成员。</p>
<ul>
<li>__dirname 可以获取当前文件模块所属目录的绝对路径 （动态的获取）<br>` __filename 可以获取当前文件的绝对路径 （动态的获取） </li>
</ul>
<p>在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node命令所处的路径（不是bug，人家这样设计是有使用场景的）<br>为了解决相对路径不可靠的问题，我们把可以使用<strong>dirname/</strong>filename来动态获取不同计算机不同存储位置的路径。在路径拼接过程中，为了避免手动修改路径出错，所以推荐多使用path.join()来辅助拼接，在以后的操作中尽可能的把绝对路径转化为相对路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/public/'</span>,express.static(path.join(__dirname,<span class="string">'./public'</span>)))</span><br><span class="line">app.use(<span class="string">'/node_modules'</span>,express.static(path.join(__dirname,<span class="string">'./node_modules'</span>)))</span><br></pre></td></tr></table></figure>
<h1 id="node中的核心模块"><a href="#node中的核心模块" class="headerlink" title="node中的核心模块"></a>node中的核心模块</h1><p>fs模块<a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html" target="_blank" rel="noopener">官方文档</a>，http模块，path路径模块，os操作系统模块。。。</p>
<h1 id="node多文件执行"><a href="#node多文件执行" class="headerlink" title="node多文件执行"></a>node多文件执行</h1><ul>
<li><p>node中没有全局作用域，只有模块作用域。</p>
<pre><code>也就是说不同文件中的内容在同一页面执行引入的时候不会相互影响。外部取不到内部的数据，内部也取不到外部的数据，但是可以执行代码。</code></pre></li>
<li><p>那么如何让node中的模块之间通讯呢？</p>
<ul>
<li>export导出模块<br>  常规导出的是express这个对象，需要通过打点或者解构来获取和调用里面的多内容<blockquote>
<p>export   abc</p>
</blockquote>
</li>
<li>require的作用<ul>
<li>1、加载并执行文件模块中的代码</li>
<li>2、拿到被加载文件模块导出的接口对象</li>
</ul>
</li>
</ul>
</li>
<li><p>ap地址和端口号</p>
<ul>
<li>每一个ip指向了一台服务器（定位计算机）</li>
<li>服务器中的每一个物联网通讯的应用程序都对应了一个端口号（端口号定位具体应用程序）</li>
<li>端口号范围 0 - 65535之间</li>
</ul>
</li>
</ul>
<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><pre><code>模板引擎起源于服务器，最后发展到了前端
- art-template（js）
- </code></pre><h1 id="node中静态资源处理方法"><a href="#node中静态资源处理方法" class="headerlink" title="node中静态资源处理方法"></a>node中静态资源处理方法</h1><p>node中为了方便静态资源管理放在public文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//得到用户的路径</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">    <span class="comment">//真的读取这个文件</span></span><br><span class="line">    fs.readFile(<span class="string">"./static/"</span> + pathname,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//如果此文件不存在，就应该用404返回</span></span><br><span class="line">            fs.readFile(<span class="string">"./static/404.html"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">                res.writeHead(<span class="number">404</span>,&#123;<span class="string">"Content-type"</span>:<span class="string">"text/html;charset=UTF8"</span>&#125;);</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>);</span><br></pre></td></tr></table></figure>


<h1 id="实现Apache"><a href="#实现Apache" class="headerlink" title="实现Apache"></a>实现Apache</h1><h1 id="推荐JavaScript的编写规范的书"><a href="#推荐JavaScript的编写规范的书" class="headerlink" title="推荐JavaScript的编写规范的书"></a>推荐JavaScript的编写规范的书</h1><blockquote>
<p>编写可维护的javascript</p>
</blockquote>
<h1 id="服务器渲染"><a href="#服务器渲染" class="headerlink" title="服务器渲染"></a>服务器渲染</h1><blockquote>
<p>也就是说在服务器使用模板引擎<br>    - 客户端渲染<br>        html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。<br>    - 服务端渲染<br>    服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。（也就是通过模板引擎把数据在服务端的时候就渲染好，收到请求之间发送页面）</p>
</blockquote>
<pre><code>- 客户端渲染与服务器渲染的区别
    - 客户端渲染不利于seo搜索引擎优化，也就是说客户端渲染的数据爬虫爬不到
    - 服务器渲染是可以被爬虫爬取到的，客户端的异步渲染是很难被爬虫爬取到的。
    - 所以一个网站，是服务器与客户端结合渲染来做的</code></pre><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><pre><code>package.json包说明书，描述你的项目使用了哪些npm包

--save 会把你安装的包放在package.json中。

同时package.json可以通过npm init初始化出来
而如果没有node——module有package.json使用npm install  会更具package.json中的依赖还原你的node_module


npm  是一个网站
npm  是一个命令行工具</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install (i)</span><br><span class="line"></span><br><span class="line">npm install 包名 --save(S)</span><br><span class="line">npm uninstall 包名</span><br><span class="line">npm help  查看使用帮助</span><br></pre></td></tr></table></figure>
<pre><code>npm被墙问题
    npm是国外网站一般使用cnpm
        npm  install --global cnpm
    如果不想通过npm安装cnpm也可以
        npm install 包 --registry=https：//registry.npm.taobao.org
        这样会比较麻烦每次安装都需要写后缀

        推荐这样
        npm config set registry https：//registry.npm.taobao.org

package.json/package-lock.json  
    - package-lock.json中存储的你项目中node_module所有的依赖信息，当你的node_module从新安装依赖的时候会比没有安装之前的速度更快。
    - 从文件来看，有一个lock  这个锁是用来锁定版本的，如果你下载的下面时1.1版本的，如果没有lock那么你npm i的时候就会默认给你安装最新的版本</code></pre><h1 id="JavaScript模块化"><a href="#JavaScript模块化" class="headerlink" title="JavaScript模块化"></a>JavaScript模块化</h1><p>JavaScript天生不支持模块化，如果浏览器需要模块化那么需要引入第三方库<br>    - require.js    AMD<br>    - sea.js    CMD<br>    上面两中都是浏览器模块化规范<br>    - common.js   common<br>    当然还有UMD、es6中的modules</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Node中我们开启的web服务是一个完全的黑盒子，所有资源都不允许用户来访问，用户可以访问的内容具体由开发人员编写设计为准。</li>
<li>在Node中可以把一个url地址处理的非常漂亮  </li>
</ul>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>vue从基础到熟悉</title>
    <url>/2020/04/03/vue%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E7%86%9F%E6%82%89/</url>
    <content><![CDATA[<h1 id="vue从基础到熟悉"><a href="#vue从基础到熟悉" class="headerlink" title="vue从基础到熟悉"></a>vue从基础到熟悉</h1><a id="more"></a>

<h1 id="一、基本指令"><a href="#一、基本指令" class="headerlink" title="一、基本指令"></a>一、基本指令</h1><ul>
<li><p>v-if</p>
<p>  如果v-if中的值为true，会渲染对应绑定的元素，若为false不会渲染对应绑定元素。（v-if有惰性）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">'istrue'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      istrue: true</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>v-show</p>
<p>  如果v-show中的值为true，会渲染并显示对应绑定的元素，若为false会渲染对应绑定元素但会被隐藏起来（display：none）。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-show=<span class="string">'istrue'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      istrue: true</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>v-for</p>
<p>  会循环遍历对应数据中的内容，并把每一次遍历出来的值渲染到dom中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">for</span>=<span class="string">"(item, index) in items"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;&#123;index&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      list: [a,b,c]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>v-text</p>
</li>
</ul>
<p>可以把数据渲染到dom中，不能识别标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-text=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: 'holle word'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-html<br>把数据渲染到dom中，可以识别标签。不会渲染内部的scrpit，为了防止xss攻击。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-html=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: '&lt;h1&gt;holle word&lt;/</span>h1&gt;<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-bind</li>
</ul>
<p>属性绑定，通过获取data中的值来控制（style，class，href，src等等的标签属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-bind:<span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span> :style = <span class="string">'&#123;color:red,fontSize:font&#125;'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: 'holle',</span></span><br><span class="line"><span class="regexp">      red: 'red',</span></span><br><span class="line"><span class="regexp">      font: '15px'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-model</li>
</ul>
<p>绑定数据源（数据双向绑定），他一些修饰符 </p>
<pre><code>- 1、lazy懒加载（输入时不会变，光标离开时更改数据）
- 2、number限制数据类型（加上这个属性只能显示数字部分，字符串会默认清空）
- 3、trim去空格（去除输入内容中的空格）</code></pre><p>可以使用数据双向绑定完成很多有用的东西，比如在一个地方需改数据，同时修改其他地方的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span>&gt;</span><br><span class="line">      &lt;input type:<span class="string">'text'</span> v-model=<span class="string">'text'</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">      &lt;label for='istrue'&gt;&#123;&#123;text&#125;&#125;&lt;/</span>label&gt;</span><br><span class="line">      &lt;input type:<span class="string">'text'</span> v-model.lazy=<span class="string">'text'</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">      &lt;label for='istrue'&gt;&#123;&#123;text&#125;&#125;&lt;/</span>label&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: false</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>v-on</li>
</ul>
<p>绑定事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input @:click = <span class="string">'letgo'</span>/&gt;</span><br><span class="line">            &lt;input v-on:click = <span class="string">''</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="string">"ok"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      letgo() &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-once</li>
</ul>
<p>对应标签中的数据只会渲染最开始的数据，渲染完成后不会根据数据的改变而改变.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span> v-once&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: "ok"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="二、全局api"><a href="#二、全局api" class="headerlink" title="二、全局api"></a>二、全局api</h1><ul>
<li>自定义指令（Vue.directive(“name”,function(el,binding,vnode){})）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span> </span>=<span class="string">"text"</span> v-news&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.directive('news',function(el,binding,vnode)&#123;</span></span><br><span class="line"><span class="regexp">  console.log(el)</span></span><br><span class="line"><span class="regexp">  el:被绑定的元素</span></span><br><span class="line"><span class="regexp">  console.log(binding)</span></span><br><span class="line"><span class="regexp">  binding：被绑定元素的详细信息，</span></span><br><span class="line"><span class="regexp">  console.log(vnode)</span></span><br><span class="line"><span class="regexp">  vnode：虚拟dom节点</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: "ok"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
自定义指令有自己独特的生命周期</li>
</ul>
<p>自定义指令生命周期<br>    - 1、bind：指令第一次绑定到元素上时，触发。<br>    2、inserted：被绑定元素插入父节点的时候调用<br>    3、update：被绑定的元素模板更改时调用<br>    4、componentUpdate：被绑定的元素所在模板更新完成时调用<br>    5、unbind：只调用一次，指令解绑的时候</p>
<ul>
<li>构造器的延申（Vue.extend）</li>
</ul>
<p>Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的vue实例构造器，经常服务于vue.component用来生成的组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id = <span class="string">"author"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;author&gt;&lt;/</span>author&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">let author = Vue.extend(&#123;</span></span><br><span class="line"><span class="regexp">  template:"&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/</span>p&gt;<span class="string">"</span></span><br><span class="line"><span class="string">  data: () &#123;</span></span><br><span class="line"><span class="string">    return&#123;</span></span><br><span class="line"><span class="string">      text:'我开我家'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">new author().$mount('#author')</span></span><br><span class="line"><span class="string">new author().$mount('author')</span></span><br><span class="line"><span class="string">//建议使用id的方式</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>全局数据操作vue.set()<br>vue.set()的作用就是在构造器外部操作构造器内部的数据。然而有很多的方法也可以完成在构造器外部操作内部数据，但是对于数组的index和长度的变化vue是监听不到的，也就是说通过数组下标或者长度来改变数组的值，vue是监听不到数据变化的，数据没有变化虚拟dom也不会进行渲染。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id = <span class="string">"app"</span>&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button onclick = 'add'&gt;&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function add() &#123;</span></span><br><span class="line"><span class="regexp">    app.data[1] = "fff"    /</span><span class="regexp">/不会更新arr的数据，导致不会触发vue渲染</span></span><br><span class="line"><span class="regexp">    Vue.set(app.arr,1,'dd') /</span><span class="regexp">/可以更新arr中的数据，会出府啊vue的渲染</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">var app = new vue(</span></span><br><span class="line"><span class="regexp">  &#123;</span></span><br><span class="line"><span class="regexp"> data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      text: "ok"</span></span><br><span class="line"><span class="regexp">      data:['aaa','bbb','ccc']</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>template模板（有三种模板形式）</p>
<ul>
<li><p>1、在实例构造器中最常见的（适用于内容比较少的模板）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">'app'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">      message:'这是模板一'</span></span><br><span class="line"><span class="regexp">    &#125;，</span></span><br><span class="line"><span class="regexp">    template: "&lt;p&gt;这是模板一&lt;/</span>p&gt;<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>2、 在dom中写模板，挂在到实例构造器中（这种方法适用于模板内容比较大的情况）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">'#app'</span>&gt;</span><br><span class="line">  &lt;template id=<span class="string">'tep'</span>&gt;</span><br><span class="line">    &lt;p&gt;这是使用方法二&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  var app = new Vue (&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    tepmplate: '#tep'</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、新建一个script标签，并在标签内部进行修改（这种方法适用于从外部引入大段模板）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">'x-template'</span> id=<span class="string">"add3"</span> src=<span class="string">''</span>&gt;</span><br><span class="line">  &lt;p&gt;我是第三中方法&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    template: <span class="string">"#add3"</span></span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定义全局组件vue.componment()</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">'x-template'</span> id=<span class="string">"add3"</span> src=<span class="string">''</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">add</span>&gt;</span><span class="tag">&lt;/<span class="name">add</span>&gt;</span></span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Vue.componment(<span class="string">'add'</span>,&#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;我爱我家&lt;/h1&gt;'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="三、声明周期"><a href="#三、声明周期" class="headerlink" title="三、声明周期"></a>三、声明周期</h1><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p>
<ul>
<li>beforecreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li>
<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>mouted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>update：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroy：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el,<span class="string">'beforeCreate'</span>) <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line">create () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el,<span class="string">'create'</span>)</span><br><span class="line">    <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line">beforeMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el,<span class="string">'beforeMount'</span>)</span><br><span class="line">    <span class="comment">//&lt;div id = 'root'&gt;&lt;/div&gt;会获取绑定的dom元素但不会数据渲染</span></span><br><span class="line">&#125;</span><br><span class="line">mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el,<span class="string">'mounted'</span>)</span><br><span class="line">    <span class="comment">//&lt;div id = 'root'&gt;0&lt;/div&gt;会把data中的数据渲染到dom上。其实template渲染实际是调用了render，也有renderError，</span></span><br><span class="line">&#125;</span><br><span class="line">beforeUpdate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el,<span class="string">'beforeUpdate'</span>)</span><br><span class="line">&#125;</span><br><span class="line">update () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el,<span class="string">'update'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>在服务端渲染的时候beforeMount和mounted不会被执行，因为没有dom操作。</p>
<p>数据请求一般放在create中去完成。</p>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><ul>
<li><p>全局扩展传参（propsDate）</p>
</li>
<li><p>计算选项  （computed）</p>
</li>
<li><p>方法选项  （method）</p>
</li>
<li><p>监听数据选项  （watch）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>轮播插件之无缝轮播失效解决方案</title>
    <url>/2020/03/31/%E8%BD%AE%E6%92%AD%E6%8F%92%E4%BB%B6%E4%B9%8B%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/f6d31e2732e0" target="_blank" rel="noopener">参考</a><br>产生无缝轮播失效的原因<br>：是因为swiper提前初始化了，那时候数据还没有完全出来</p>
<ul>
<li><ol>
<li>使用vue提供的$nextTick()方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">var</span> swiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">		此处省略</span><br><span class="line">         &#125;）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>2、在swiper初始化的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">swiper1 = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">    initialSlide :<span class="number">0</span>,</span><br><span class="line">    observer:<span class="literal">true</span>,<span class="comment">//修改swiper自己或子元素时，自动初始化swiper</span></span><br><span class="line">    observeParents:<span class="literal">true</span><span class="comment">//修改swiper的父元素时，自动初始化swiper</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>路由守卫</title>
    <url>/2020/03/28/%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h1 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h1><a id="more"></a>
<p>老规矩先去刷一遍<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">官网</a></p>
<ul>
<li>1、全局前置守卫beforEach<blockquote>
<p>router.beforeEach((to, from, next) =&gt; {})</p>
</blockquote>
</li>
<li>2、全局解析守卫beforeResolve<blockquote>
<p>router.beforeRsolve((to, from, next) =&gt; {})</p>
</blockquote>
</li>
<li>3、全局后置钩子afterEach（少用）<blockquote>
<p>router.afterEach((to, from) =&gt; {}）</p>
</blockquote>
</li>
<li>4、路由独享的守卫<blockquote>
<p>直接在路由配置上定义beforEach</p>
</blockquote>
</li>
<li>5、组件内的守卫<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate</li>
<li>beforeRouteLeave</li>
</ul>
</li>
<li>6、路由导航解析<ul>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>axios基本操作</title>
    <url>/2020/03/27/axios%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="axios基本操作"><a href="#axios基本操作" class="headerlink" title="axios基本操作"></a>axios基本操作</h1><a id="more"></a>

<p>开始学习前一定要先去<a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">官网</a>看一看，太详细了。</p>
<h1 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a>什么是axios</h1><pre><code>Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中。vue-resource在2.5版本后官方就不在维护，并推荐大家使用Axios</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>1、请求</li>
</ul>
<p>post请求（通过配置请求，直接请求）<br>get请求  （通过配置请求，直接请求）<br>默认请求 （Axios默认发送get请求）<br>多并发请求</p>
<ul>
<li><p>1、 迭代请求</p>
</li>
<li><p>2、 等待请求</p>
</li>
<li><p>2、配置</p>
</li>
<li><p>请求配置（发送前需要配置的内容）</p>
</li>
<li><p>响应结构（响应后返回的数据）</p>
</li>
<li><p>默认配置</p>
</li>
<li><p>1、全局默认值（moudle文件中已经配置好了，有修改需求才修改）</p>
</li>
<li><p>2、自定义默认值（自己创建的axios实例需要配置，不配置就会延用默认配置）</p>
</li>
<li><p>3、拦截器（会在请求响应被then，catch处理前拦截它们）</p>
</li>
<li><p>1、请求拦截器</p>
</li>
<li><p>2、响应拦截器</p>
</li>
<li><p>3、拦截器的移出</p>
</li>
<li><p>4、创建实例</p>
</li>
<li><p>建议创建实例来进行代码编写（原因：通过axios直接绑定都会直接绑定到全局上面，这样就会有一个累计拦截的问题，每次请求服务器的时候都会触发一次axios拦截，但是如果使用实例那么对应实例的多次拦截次数并不会增加。也就是说直接使用axios拦截几次就是几次，使用实例每个实例都只算一次拦截）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex解析</title>
    <url>/2020/03/26/vuex%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="vuex基本使用"><a href="#vuex基本使用" class="headerlink" title="vuex基本使用"></a>vuex基本使用</h1><a id="more"></a>
<p>建议先去看一下<a href="https://www.jianshu.com/p/2e5973fe1223" target="_blank" rel="noopener">简书</a>中下大概介绍。下面就是一个大概的总结。</p>
<ul>
<li><p>vuex的组成部分</p>
<ul>
<li>1、state：数据存储（类似与vue中的data）</li>
<li>2、mutations：对state中数据的操作（类似于vue中的method）</li>
<li>3、getters：加工state中的数据返回给外界（类似于compute计算属性）</li>
<li>4、actions：可以处理异步的方法，mutations只可以处理同步的方法</li>
<li>5、modules：vuex模块化</li>
</ul>
</li>
<li><p>1.1、vuex初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建VueX对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.2、vuex挂载到vue实例中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,  <span class="comment">//store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这一步挂载到实例中，会挂载到根vue上，在其他组件中不需要引入就可以之间通过 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.name (+对应的数据)</span><br></pre></td></tr></table></figure>
<p>的方法获取vuex中的数据</p>
</li>
</ul>
<hr>
<hr>
<hr>
<h2 id="内容的基本使用"><a href="#内容的基本使用" class="headerlink" title="内容的基本使用"></a>内容的基本使用</h2><ul>
<li>1.1、Mutations基本配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">    <span class="comment">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class="line">    edit(state,payload)&#123;</span><br><span class="line">        <span class="comment">//state state对象</span></span><br><span class="line">        <span class="comment">//payload 方法调用的时候传递的参数是一个对象&#123;&#125;</span></span><br><span class="line">        state.name = <span class="string">'jack'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>1.2、Mutations的调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过这个就可以调用对应的方法，修改state中的数据</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<hr>
<ul>
<li>2.1、Getters</li>
</ul>
<p>可以对state中的成员加工后传递给外界</p>
<ul>
<li><p>Getters中的方法有两个默认参数</p>
<ul>
<li>1、state 当前VueX对象中的状态对象</li>
<li>2、getters 当前getters对象，用于将getters下的其他getter拿来用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    nameInfo(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名:"</span>+state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    fullInfo(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.nameInfo+<span class="string">'年龄:'</span>+state.age</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
组件中调用<blockquote>
<p>this.$store.getters.fullInfo</p>
</blockquote>
</li>
</ul>
</li>
<li><p>3、 Actions</p>
</li>
</ul>
<p>由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。</p>
<ul>
<li><p>Actions中的方法有两个默认参数</p>
<ul>
<li>1、context 上下文(相当于箭头函数中的this)对象</li>
<li>2、payload 挂载参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    aEdit(context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
组件调用<blockquote>
<p>this.$store.dispatch(‘aEdit’,{age:15})</p>
</blockquote>
</li>
</ul>
</li>
<li><p>4、 Models<br>模块目前还没有用过可以先看看<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">官网</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基础操作</title>
    <url>/2020/03/24/webpack%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="webpack基础操作"><a href="#webpack基础操作" class="headerlink" title="webpack基础操作"></a>webpack基础操作</h1><a id="more"></a>
<h2 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h2><ul>
<li><p>全局安装</p>
<blockquote>
<p>npm i -g webpack</p>
</blockquote>
</li>
<li><p>打包</p>
</li>
</ul>
<blockquote>
<p>方法一 ：webpack main.js bundle.js(第一个为入口文件，编译后形成的文件)</p>
</blockquote>
<p>再把打包后的文件bundle.js引入到html中</p>
<blockquote>
<p>方法二：在根目录下加入webpack.config.js文件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry : main.js,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname,<span class="string">"./dist/"</span>),  <span class="comment">//必须时绝对路径</span></span><br><span class="line">        filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在终端中输入webpack就可以了，webpack时基于node环境的，所以可以之接引入path。</p>
<hr>
<ul>
<li>局部安装(推荐使用)<blockquote>
<p>npm i -D webpack webpack -cli   //安装</p>
</blockquote>
</li>
</ul>
<p>安装完成后需要对npm script进行配置（也就是在package。json文件中的scripts属性中进行配置）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">    bundle: 'webpack',   //默认会去node_modules中的找webpack</span><br><span class="line">    自定义名： ‘文件地址’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行npm run bundle<br>本地安装的必须配置到npm scritps中才可以使用</p>
</blockquote>
<hr>
<ul>
<li>总结</li>
</ul>
<p>全局安装webpack一般会在测试的时候使用，因为全局安装时在你的电脑上安装webpack，如果把项目发给其他人，他的电脑上面的webpack版本与你的不一致那么就会出现编译错误或无法编译。</p>
<p>局部安装会安装到你的项目中，及时把项目发送给其他人，项目编译也会去找项目中的webpack，这样就不会出现版本不同而导致的无法编译的问题。</p>
<p>为了划分目录清晰我们对项目做以下划分</p>
<ul>
<li>把源码存储到src文件夹中</li>
<li>把打包的结果存在dist文件夹中</li>
</ul>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="Es6模块规范"><a href="#Es6模块规范" class="headerlink" title="Es6模块规范"></a>Es6模块规范</h1><ul>
<li><p>默认导入导出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 导出</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            aa: <span class="number">5</span>,</span><br><span class="line">            bb: <span class="number">8</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#导入</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line">这种引入方式只会引入默认的内容（也就是<span class="keyword">export</span> <span class="keyword">default</span> 中的内容）</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通导入导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">'哈哈'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">'喜喜'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">"path"</span></span><br><span class="line">这种的导出方式，导入需要先结构，结构完成后的 a === 导出中的a</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>1、默认导入导出与普通的导入导出之间的存在是互不影响的。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<hr>
<hr>
<h1 id="css的打包"><a href="#css的打包" class="headerlink" title="css的打包"></a>css的打包</h1><ul>
<li><p>1、首先需要安装两个包</p>
<blockquote>
<p>npm i -D css-loader style-loader</p>
</blockquote>
</li>
<li><p>2、配置（找到webpack的配置文件）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#在最下面输入</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            text: <span class="regexp">/.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">'style.loader'</span>,  <span class="comment">//这个包会在html文件中的head部分插入一个style并把css的文件自动引入</span></span><br><span class="line">                <span class="string">'css-loader'</span>   <span class="comment">//这个包会把css文件转化为js文件</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3、配置完成后据可以使用</p>
<blockquote>
<p>npm run build  //打包</p>
</blockquote>
<h1 id="图片打包"><a href="#图片打包" class="headerlink" title="图片打包"></a>图片打包</h1><p>安装插件</p>
<blockquote>
<p>npm install –save-dev file-loader<br>安装完成后，取药去weback.config文件中进行配置<br>在rules中加个对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#123;</span><br><span class="line">    test: &#x2F;.(jpg|png|gif|svg)$&#x2F;,</span><br><span class="line">    use: [  </span><br><span class="line">        &#39;filer-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会把图片打包到dist文件夹中，但是这是你使用浏览器打开的时候控制台会报错，没有找到图片。这是因为打包好的图片贺html文件不在同一个地方，他找不到。解决方法：把html文件也自动打包到dist文件夹中</p>
<h1 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h1></li>
</ul>
<p>webpack默认只会打包js文件。因此需要映入很多其他的包来进行打包。</p>
<p> 会把源码的html文件打包到dist文件中。会自动引入html需要的图片。</p>
<ul>
<li><p>安装依赖</p>
<blockquote>
<p>npm install –save-dev html-webpack-plugin</p>
</blockquote>
</li>
<li><p>配置</p>
<p>在webpack配置文件中加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先在全局中引入  webpack-olugin</span><br><span class="line">const htmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line">在moudle上面添加</span><br><span class="line">plugins: [</span><br><span class="line">    new htmlWebpackPlugin(&#123;</span><br><span class="line">        template: &#39;.&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="less打包"><a href="#less打包" class="headerlink" title="less打包"></a>less打包</h1></li>
<li><p>安装依赖</p>
<blockquote>
<p>npm install -D less less-loader</p>
</blockquote>
<ul>
<li>配置</li>
</ul>
</li>
</ul>
<p>在webpack配置文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在rulers中进行配置</span><br><span class="line">&#123;</span><br><span class="line">    test: &#x2F;.less$&#x2F;,</span><br><span class="line">    use: [</span><br><span class="line">        &#39;style-loader&#39;,</span><br><span class="line">        &#39;css-loader&#39;,</span><br><span class="line">        &#39;less-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p>会在自动根据代码完成情况来自动打包，不需要写一下就要打包一下</p>
<ul>
<li>安装依赖<blockquote>
<p>npm install –save-dev webpack-dev-server</p>
</blockquote>
</li>
<li>配置</li>
</ul>
<p>在webpack配置文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: &#39;.&#x2F;dist&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后需要去webpack.json文件中的script中配置</p>
<blockquote>
<p>‘dev’: ‘webpack-dev-server –open’</p>
</blockquote>
<h1 id="bable-loader"><a href="#bable-loader" class="headerlink" title="bable-loader"></a>bable-loader</h1><p>es6转码器，bable打包编译很慢，需要在webpack.config文件中的bable配置规则中配置打包缓存，属性cacheDirectory：true</p>
<h1 id="bable-polyfill"><a href="#bable-polyfill" class="headerlink" title="bable-polyfill"></a>bable-polyfill</h1><p>用于提供低版本浏览器不支持的api</p>
<h1 id="tansfrom-runtime"><a href="#tansfrom-runtime" class="headerlink" title="tansfrom-runtime"></a>tansfrom-runtime</h1><p>解决代码重复问题，需要在webpack.config文件中的bable配置规则中配置打包缓存，属性plugins：【tansfrom-runtime】</p>
<h1 id="vue-Loader"><a href="#vue-Loader" class="headerlink" title="vue Loader"></a>vue Loader</h1><p>处理打包单文件组件vue的打包问题，包括css，es6等。需要依赖vue-template-loader</p>
]]></content>
  </entry>
  <entry>
    <title>“css sticky footer</title>
    <url>/2020/03/22/%E2%80%9Ccss-sticky-footer/</url>
    <content><![CDATA[<h1 id="CSS经典布局之Sticky-footer布局"><a href="#CSS经典布局之Sticky-footer布局" class="headerlink" title="CSS经典布局之Sticky footer布局"></a>CSS经典布局之Sticky footer布局</h1><a id="more"></a>
<p>我们常见的网页布局方式一般分为header（页头）部分,content（内容区）部分和footer（页脚）部分。当页头区和内容区的内容较少时，页脚区不是随着内容区排布而是始终显示在屏幕的最下方。当内容区的内容较多时，页脚能随着文档流撑开始终显示在页面的最下方。这就是传说中的Sticky footer布局。</p>
<ul>
<li>负margin布局方式</li>
</ul>
<p>html模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper clearfix"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是头部<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是main content区域...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 2017 No rights reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Made with ♥ by an anonymous pastafarian.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.detail</span>&#123;</span><br><span class="line">     <span class="attribute">position</span>:fixed;</span><br><span class="line">     <span class="attribute">overflow</span>:auto;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">     <span class="attribute">min-height</span>:<span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.title</span> <span class="selector-tag">h1</span>&#123;</span><br><span class="line">     <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">     <span class="attribute">margin-top</span>:<span class="number">64px</span>;</span><br><span class="line">     <span class="attribute">padding-bottom</span>:<span class="number">64px</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.main</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">25px</span>; </span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">     <span class="attribute">margin</span>:-<span class="number">64px</span> auto <span class="number">0</span> auto;</span><br><span class="line">     <span class="attribute">font-size</span>:<span class="number">32px</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: block;</span><br><span class="line">     <span class="attribute">content</span>: <span class="string">"."</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">clear</span>: both;</span><br><span class="line">     <span class="attribute">visibility</span>: hidden;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>main里面padding-bottom的值与footer中的负margin值要保持一直</p>
</blockquote>
<ul>
<li>flex布局方式</li>
</ul>
<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Site name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 2017 No rights reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Made with ♥ by an anonymous pastafarian.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-tag">body</span>&#123;<span class="attribute">display</span>: flex; <span class="attribute">flex-flow</span>: column; <span class="attribute">min-height</span>: <span class="number">100vh</span>; <span class="attribute">overflow</span>:auto;&#125;</span><br><span class="line"> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>: <span class="number">60px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line"> <span class="selector-tag">p</span>&#123;<span class="attribute">font-size</span>: <span class="number">24px</span>; <span class="attribute">text-align</span>: center;&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;<span class="attribute">flex</span>:<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>flex布局结构简单，代码精简。因为flex存在着兼容性，所以在使用这种方式布局时需要注意。</p>
</blockquote>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>路由模块化</title>
    <url>/2020/03/21/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="路由模块化"><a href="#路由模块化" class="headerlink" title="路由模块化"></a>路由模块化</h1><p>平时我们使用路由都是这样子的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">"/login"</span><span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;&#125;)</span><br><span class="line">app.get(<span class="string">"/regirse"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>如果要配置子路由那么有需要这样一条一条的来写，那么现在我们使用了模块化之后，就会非常方便。</p>
<blockquote>
<p>创建一个文件夹 mode.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> routers = express.Router()</span><br><span class="line">routers.get(<span class="string">"/good"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">routers.get(<span class="string">"/send"</span><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  app.use(<span class="string">"/api"</span> routers)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>canvas基础教程</title>
    <url>/2020/03/18/canvas%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="canvas基础教程"><a href="#canvas基础教程" class="headerlink" title="canvas基础教程"></a>canvas基础教程</h1><a id="more"></a>
<p>canvas是H5新增的一个绘制标签，display是line类型。控制他的大小需要把盒子类型设置为display：block。之后就可以设置自己画布的大小（canvas画布的大小），绘制过程在js部分进行。</p>
<hr>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><ul>
<li>1、获取对应canvas标签<blockquote>
<p>let canvas = document.getElementById(“canvas”)</p>
</blockquote>
</li>
<li>2、创建画笔<blockquote>
<p>let cxt = canvas.getContext(“2d”)  //这里也可以写3d</p>
</blockquote>
</li>
<li>3、设置画笔样式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cxt.lineJoin = round/beter<span class="string">""</span> 线段闭合处边角</span><br><span class="line">cxt.strokeStyl<span class="string">""</span>设置画笔颜色，</span><br><span class="line">cxt.lineWidth=<span class="string">""</span>设置画笔粗细</span><br><span class="line"></span><br><span class="line">ctx.lineCap=<span class="string">"round"</span>一条线段的两端样式  两端边圆角，两端增加现款一半</span><br></pre></td></tr></table></figure></li>
<li>4、习惯<br>每次重新绘制图形的时候一定要使用<br>beginPath来把每个图像进行隔离<br>cxt.closePath()把路径合并<br>cxt.beginPath()开始绘制一个路径</li>
</ul>
<hr>
<h2 id="第二部"><a href="#第二部" class="headerlink" title="第二部"></a>第二部</h2><pre><code>这里我们就可以进行绘制图像</code></pre><hr>
<ul>
<li>1、绘制长方形</li>
</ul>
<p>方法一<br>创建绘制计划</p>
<blockquote>
<p>canvas.rect(x,y,w,h)</p>
</blockquote>
<p>x：起始点横坐标坐标<br>y：起始点纵坐标<br>w：矩形宽度<br>h：矩形高度</p>
<p>开始绘制</p>
<blockquote>
<p>cxt.fill()    //绘制实心的矩形</p>
</blockquote>
<blockquote>
<p>cxt.stroke()   //绘制空心的矩形</p>
</blockquote>
<p>这里有还有另一种绘制的方法，绘制计划与执行一起</p>
<blockquote>
<p>cxt.fillRect(x,y,w,h)//绘制实心矩形</p>
</blockquote>
<blockquote>
<p>cxt.strokeRect(x,y,w,h)//绘制空心矩形</p>
</blockquote>
<hr>
<ul>
<li>2、绘制圆形<blockquote>
<p>cxt.arc(x,y,r,regb,rege,driction)//指定画园计划</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>cxt.fill()绘制实心园</p>
</blockquote>
<blockquote>
<p>cxt.stroke()绘制空心园</p>
</blockquote>
<p>x:起始点<br>y:起始点<br>r：圆的半径<br>regb：开始角度<br>rege：结束角度<br>driction：画原方向（默认false）</p>
<ul>
<li>3、绘制文字<blockquote>
<p>cxt.fillText(“content”,x,y)//绘制实心文字</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>cxt.strokeText(“content”,x,y)//绘制空心文字</p>
</blockquote>
<p>content：文字内容<br>x：起始点横坐标<br>y：起始点纵坐标</p>
<ul>
<li>4、绘制文字的样式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cxt.font(字体大小,字体类型)</span><br><span class="line">cxt.textAlign = <span class="string">"center"</span>文字居中对齐</span><br><span class="line">cxt.Baseline = <span class="string">"center"</span>基线对齐</span><br><span class="line">cxt.shadowffsetx=<span class="number">10</span></span><br><span class="line">cxt.shadowColor = <span class="string">""</span></span><br></pre></td></tr></table></figure></li>
<li>5、渐变</li>
</ul>
<p>线性渐变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   color = cxt.createLinearGradient()</span><br><span class="line">color.addColorStop(<span class="number">0</span>,red)    </span><br><span class="line">   color.addColorStop(<span class="number">1</span>,bule)</span><br><span class="line">cxt.fillStyle = color</span><br><span class="line">画笔使用color配置的颜色</span><br></pre></td></tr></table></figure>

<p>径向渐变</p>
<blockquote>
<p>color =cxt.createRadialGradient(圆形坐标x，y，r，x，y，r)</p>
</blockquote>
<ul>
<li>绘制线段<br>cxt.moveTo(起始点的x，y)<br>cxt.lineTo（中止点的x，y）<br>cxt.stroke()</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>node中神奇的包-bcryptjs加密解密</title>
    <url>/2020/03/18/node%E4%B8%AD%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8C%85-bcryptjs%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="node中神奇的包-bcryptjs加密解密"><a href="#node中神奇的包-bcryptjs加密解密" class="headerlink" title="node中神奇的包-bcryptjs加密解密"></a>node中神奇的包-bcryptjs加密解密</h1><ul>
<li>什么是bcrypyjs？<blockquote>
<p>bcryptjs是一个第三方密码加密库，是对原有的bcrypt的优化，优点是不需要安装任何依赖</p>
</blockquote>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000008841988" target="_blank" rel="noopener">具体使用可以看看这里</a></p>
<ul>
<li>下面我们来讲讲文档上面没有的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//salt是设置加密的强度 最高好像就是10</span></span><br><span class="line"><span class="keyword">var</span> salt = bcrypt.genSaltSync(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<a href="https://segmentfault.com/a/1190000013165651" target="_blank" rel="noopener">基本运行原理可以点击这里</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mongoose的基本使用</title>
    <url>/2020/03/18/mongoose%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="mongoose的基本使用"><a href="#mongoose的基本使用" class="headerlink" title="mongoose的基本使用"></a>mongoose的基本使用</h1><a id="more"></a>

<ul>
<li>在开始之前，没有什么比先去官网刷一遍更有用的了<a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">mongoose官网</a></li>
</ul>
<blockquote>
<p>mongoose 是什么？他有什么用呢？</p>
</blockquote>
<blockquote>
<p>mongoose 是操作 MongoDB 的一个对象模型库；它封装了MongoDB对文档操作的常用处理方法（增删改查），让 NodeJS 操作 Mongodb 数据库变得快捷灵活。</p>
</blockquote>
<ul>
<li>下面我们来看看这个例子</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/test"</span>);</span><br><span class="line"><span class="comment">// var testModel = db.model('test1', testSchema); // 集合名称；集合的结构对象</span></span><br><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> TestModel = db.model(<span class="string">"test1"</span>, TestSchema );</span><br><span class="line"><span class="keyword">var</span> TestEntity = <span class="keyword">new</span> TestModel(&#123;</span><br><span class="line">    name : <span class="string">"helloworld"</span>,</span><br><span class="line">    age  : <span class="number">28</span>,</span><br><span class="line">    email: <span class="string">"helloworld@qq.com"</span></span><br><span class="line">&#125;);</span><br><span class="line">TestEntity.save(<span class="function"><span class="keyword">function</span>(<span class="params">error,doc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"error :"</span> + error);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力，因为mongodb不具备sql数据库的那种紧密的关系同时我们需要保证数据的完整性，因此我们需要制定一个规则骨架来约束用户。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Model ： 由 Schema 发布生成的模型，具有抽象属性和行为的数据库操作(也就是说把框架转化为一个可以使用的模型)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TestModel = db.model(<span class="string">"test1"</span>, TestSchema );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Entity ： 由 Model 创建的实体，他的操作也会影响数据库</p>
</blockquote>
<ul>
<li>那么Model和Entity有什么区别呢？三者又有什么关系呢？<blockquote>
<p>Model 与 Entity没有什么区别，唯一区别就是使用的操作型上面。Model 和 Entity 都可对数据库操作造成影响，但 Model 比Entity 更具操作性。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Schema 生成 Model，Model创造 Entity;</p>
</blockquote>
<hr>
<h2 id="Model-数据插入"><a href="#Model-数据插入" class="headerlink" title="Model 数据插入"></a>Model 数据插入</h2><hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">  age: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  email: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">  time: &#123;<span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> testModel = db.model(<span class="string">'test1'</span>, testSchema); <span class="comment">// 集合名称；集合的结构对象</span></span><br><span class="line"><span class="comment">// Document文档（关联数组式的对象） &lt; Collection集合 &lt; 数据库</span></span><br><span class="line"><span class="comment">// 插入保存一段数据</span></span><br><span class="line">testModel.create([</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test1"</span>, <span class="attr">age</span>: <span class="number">8</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test2"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test3"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test4"</span>, <span class="attr">age</span>: <span class="number">38</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test5"</span>, <span class="attr">age</span>: <span class="number">48</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test6"</span>, <span class="attr">age</span>: <span class="number">58</span>, <span class="attr">email</span>:<span class="string">"tttt@qq.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test7"</span>, <span class="attr">age</span>: <span class="number">68</span>, <span class="attr">email</span>:<span class="string">"ssss@qq.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test8"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test9"</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">email</span>:<span class="string">"rrrr@qq.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"test10"</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">error, docs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'save ok'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>find数据查询<blockquote>
<p>mongoose 提供了find、findOne、和findById方法用于文档查询。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model.find(Conditions,fields,options,callback(err, doc));</span><br><span class="line">model.find(&#123;<span class="string">"name"</span>:<span class="string">"zs"</span>&#125;,callback(err, doc));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Conditions: 查询条件<br>fields: 返回的字段<br>options: 游标（sort,limit）<br>callback: 回调函数，参数doc为查询出来的结果</p>
</blockquote>
<ul>
<li><p>update 数据更新</p>
<blockquote>
<p>基本使用：model.update(查询条件,更新对象,callback);<br>model.findByIdAndUpdate(id,更新的内容,callback)</p>
</blockquote>
</li>
<li><p>remove 删除数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本使用：</span></span><br><span class="line"><span class="comment">//删除查询到的所有数据</span></span><br><span class="line">model.remove(查询条件,callback);</span><br><span class="line"><span class="comment">//删除查询到的一条数据</span></span><br><span class="line">model.findOneAndRemove(查询条件，callback)</span><br><span class="line">model.findByIdAndRemove(id，callback)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>express框架使用指南</title>
    <url>/2020/03/16/express%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="express框架使用指南"><a href="#express框架使用指南" class="headerlink" title="express框架使用指南"></a>express框架使用指南</h1><p><a href="http://expressjs.com/" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>
<ul>
<li>express介绍</li>
</ul>
<p>Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架<br>Express 框架是后台的 Node 框架，所以和 jQuery、zepto、yui、bootstrap<br>都不一个东西。<br>Express 在后台的受欢迎的程度类似前端的 jQuery，就是企业的事实上的标<br>准。</p>
<ul>
<li><p>express的特点</p>
<ul>
<li>Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供<br>系列强大的特性，帮助你创建各种 Web 和移动设备应用</li>
<li>丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友<br>好的 API 变得既快速又简单</li>
</ul>
</li>
<li><p>express的安装</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网： http:&#x2F;&#x2F;expressjs.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>  安装 Express 框架，就是使用 npm 的命令。（安装在需要使用express模板的文件夹）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure>

<p>  在完成上面安装的操作步骤后就可以使用express开发啦~</p>
</li>
</ul>
<ul>
<li>express的使用<br>  express有基本的识别能力，不需要自己添加contenttype/同时会内置处理没有配置的路径。相比于原生http的自己封装请求头，已经路由判断来说方便多了。<br>  0、配置公开资源目录(可以公开访问public下的所有文件)<blockquote>
<p>app.use(‘/public/‘,express.static(‘./public/‘))<br>  第一个public是别名,后面的是对应文件地址<br>  输入网址的时候例如<br><a href="http://www.localhost:3000/public/css/index.css" target="_blank" rel="noopener">http://www.localhost:3000/public/css/index.css</a><br>  还有第二种方式<br>app.use(express.static(‘./public/‘))<br>  这里输入网址的时候应该时这样<br><a href="http://www.localhost:3000/css/index.css" target="_blank" rel="noopener">http://www.localhost:3000/css/index.css</a><br>  不需要添加public</p>
</blockquote>
</li>
</ul>
<pre><code>0.1、修改代码自动重启
nodemon来解决修改代码重启的操作
&gt;npm install --global nodemon
启动文件的时候，使用nodemon启动就可以了
&gt;nodemon app.js
当文件变化时会自动帮你重启服务器

1、express的简单使用

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1、引入express到项目中 </span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2、实例一个对象 </span></span><br><span class="line"><span class="keyword">let</span> app = express() </span><br><span class="line"></span><br><span class="line"><span class="comment">//这里也可以在express前面加上一个new</span></span><br><span class="line"><span class="comment">//let app = new express()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;!-- 3、配置路由 --&gt;</span></span><br><span class="line">app.get(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req , res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"向前端发送的数据"</span>)</span><br><span class="line">    <span class="comment">//res.end("向前端发送的数据")</span></span><br><span class="line">    <span class="comment">//这里end 和 send 都可以向前台发送数据</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>)</span><br></pre></td></tr></table></figure>
上面这个例子是基于get传参的express框架的简单配值，配置完成后就可以在对应文件夹中打开终端输入```node 你的文件名.js ```就可以运行了。对于post传值我们下面会介绍到。
1.1、express中的res有多种方法
- send
` json 传入一个对象会默认把对象转换为json数据

2、动态路由

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1、引入express到项目中 </span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2、实例一个对象 </span></span><br><span class="line"><span class="keyword">let</span> app = express() </span><br><span class="line"></span><br><span class="line"><span class="comment">//这里配置的是二级动态路由</span></span><br><span class="line">app.get(<span class="string">"/news/:aid"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req , res</span>)</span>&#123;</span><br><span class="line">    req.params</span><br><span class="line">    <span class="comment">//req.params这个方法会得到动态路由的值</span></span><br><span class="line">    res.send(<span class="string">"向前端发送的数据"</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>)</span><br></pre></td></tr></table></figure>
在这个例子中大家可能不太懂这到底实在干什么那么，什么又是动态路由，下面我来给大家分析一下。

当我们在终端中运行node之后，通过浏览器打开 localhost/3000 就会弹出express运行的页面，当把网站变为localhost/news 就会进入到news的页面（news就是一级路由，在news后面二级路由以此类推） 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(/news/:路由的key)  key可以是任意单词，但是“：”不能省略</span></span><br><span class="line">app.get(<span class="string">"/news/:aid"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"动态路由"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
动态路由就是没有把路由地址写死，如上你可以在浏览器的news后面加上任意路由，页面都是可以进行访问的。但如果你写死了那么，你只能访问对应的路由，如果路由不匹配那么页面就会显示你访问的页面不存在。

2.1、路由重定向
&gt;res.redirect(&apos;/&apos;)
2.2、获取post传递数据
express中没有内置获取post请求体的api，我们需要结合第三方包
结合第三方插件  body-parser
&gt;npm install body-parser --save
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">/*引入*/</span> </span><br><span class="line"> <span class="keyword">var</span> body = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"> <span class="comment">//添加了这个配置后   req的请求对象中会多出来一个属性：body，我们可以通过这个body来获取表单的数据。</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 解析 application/json</span></span><br><span class="line">app.use(bodyParser.json()); </span><br><span class="line"><span class="comment">// 解析 application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;));</span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> express(); <span class="comment">/*实例化*/</span></span><br></pre></td></tr></table></figure>

2.3、以上都是非模块化的路由，如果你想让node模块化，你需要在根目录新建一个router.js，如下
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
express对象中有个router方法，用来存放你所配置的路由。
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'./router'</span>)</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure>



3、get传值

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">/*引入*/</span> </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> express(); <span class="comment">/*实例化*/</span> </span><br><span class="line">app.get(<span class="string">'/login?user="haha"&amp;password=123'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query)</span><br><span class="line">    <span class="comment">//req.query  这个方法会获得？后面的值，返回一个对象</span></span><br><span class="line">     res.send(<span class="string">'你好express'</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//res.send()  res.redirect()都会结束响应  与原生的write不同</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

4、express中使用ejs模板

&gt; 安装：</code></pre><p>npm install ejs –save</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置ejs模板引擎 */</span> </span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'ejs'</span>);</span><br><span class="line"> <span class="comment">//设置模板的位置 </span></span><br><span class="line"> app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);</span><br><span class="line"></span><br><span class="line"> app.get(<span class="string">"/news"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">     res.render(<span class="string">"index"</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//  这里与就是ejs中ejs.renderFile()一样</span></span><br><span class="line">    res.send(<span class="string">"ejs模板使用"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

5、中间件</code></pre><ul>
<li><p>应用级中间件</p>
<blockquote>
<p>在输入对应端口进入，对页面跳转进行拦截，根据回调函数来判断进入页面的条件，满足一定条件才可以进入页面（类似于vue中的路由守卫）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);<span class="comment">/*引入*/</span> </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> express(); <span class="comment">/*实例化*/</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()); next(); &#125;)</span><br></pre></td></tr></table></figure>
<p>只有这个中间件的回调函数中存在next（）方法的调用那么才可以继续继续跳转</p>
</li>
<li><p>路由中间件</p>
<blockquote>
<p>多个相同的路由地址，那么他会不会全部匹配呢，答案是否定的。他会匹配第一个设置的路由之后就不会在匹配其他相同的路由了。如果需要对应页面的数据/跳转的下一个一页面那么就需要在第一个路由中设置next（）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/news'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'新闻路由中间件通过app.use'</span>); </span><br><span class="line">     next();</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/news'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'新闻路由'</span>); </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误处理中间件</p>
<blockquote>
<p>就是通过应用中间件，对请求的状态进行判断，若状态码为404就会抛出对应信息。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123; res.status(<span class="number">404</span>).send(<span class="string">'这是404 表示路由没有匹配到'</span>) &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置中间件</p>
<blockquote>
<p>内置中间件用来托管静态页面</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>,express.static(__dirname+<span class="string">'/public'</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你输入static的路由会之间自动匹配到public文件夹中的内容</p>
</blockquote>
</li>
<li><p>第三方中间件</p>
<blockquote>
<p>body-parser ：解析body中的数据，并将其保存为Request对象的body属性。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>cookie-parser ：解析客户端cookie中的数据，并将其保存为Request对象的cookie属性</p>
</blockquote>
<blockquote>
<p>express-session ：解析服务端生成的sessionid对应的session数据，并将其保存为&gt;Request对象的session属性</p>
</blockquote>
<blockquote>
<p>query：这个中间件将一个查询字符串从URL转换为JS对象，并将其保存为Request对象的&gt;query属性。这个中间件在第四个版本中已经内置了无需安装。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置body-parser中间件 </span></span><br><span class="line"><span class="comment">// parse application /x-www-form-urlencoded </span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"><span class="comment">// parse application/json </span></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.post(<span class="string">"/login"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    req.body <span class="comment">//获得post传递过来的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>req.body就可以获得想要需要的数据，这些body的配置信息有什么用呢？</p>
<blockquote>
<p>bodyParser.json()  用来解析json格式的数据 本返回一个中间件到node中的applaction级<br>bodyParser.urlencoded()  用来解析表单格式的数据 本返回一个中间件到node中的applaction级<br><a href="https://www.jianshu.com/p/cd3de110b4b6" target="_blank" rel="noopener">详细介绍</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>解析node.js中的非阻塞Io</title>
    <url>/2020/03/16/0%E5%9F%BA%E7%A1%80%E8%A7%A3%E6%9E%90node-js/</url>
    <content><![CDATA[<h1 id="解析node-js中的非阻塞Io"><a href="#解析node-js中的非阻塞Io" class="headerlink" title="解析node.js中的非阻塞Io"></a>解析node.js中的非阻塞Io</h1><a id="more"></a>
<h2 id="io"><a href="#io" class="headerlink" title="io"></a>io</h2><p>1、首先什么是io？</p>
<ul>
<li>IO （计算机用语），io是计算机的一种硬件，主要用来处理数据的输入输出，I/O输入/输出(Input/Output)  ，I/O操作可以有多种方式，比如DIO(Direct I/O)，AIO(Asynchronous I/O，异步I/O)，Memory-Mapped I/O(内存映射I/O)等，不同的I/O方式有不同的实现方式和性能，在不同的应用中可以按情况选择不同的I/O方式。（这里的异步io不等于我们今天学习的非阻塞io）。</li>
</ul>
<p><a href="https://baike.baidu.com/item/IO/5918?fr=aladdin" target="_blank" rel="noopener">参考文档</a></p>
<p>2、io操作又是什么？</p>
<ul>
<li>说了一大堆到底什么是io操作呢？  通俗的来讲就是数据在计算机内部的输入与输出。例如：我们把io比作一个污水处理厂，污水的输入和清水的输出。并且io操作十分耗时，在阻塞io机制中，他需要等对应的数据内容读完后才会执行代码渲染，这个过程可能会消耗10s的事件。对于码农来说这已经是天文数字了。</li>
</ul>
<h2 id="Node中阻塞Io"><a href="#Node中阻塞Io" class="headerlink" title="Node中阻塞Io"></a>Node中阻塞Io</h2><p>1、什么是非阻塞io<br>非阻塞io是io数据处理方式的一种，这种处理方式不会导致进程的堵塞，类似与js中的异步。当碰到没有调用的程序他不会等这函数调用后在继续执行代码，而是跳过他执行下面的操作。那么万一在后面这个函数被调用了呢？那就是我要说的第二点。</p>
<p>2、非阻塞Io的运行原理</p>
<p>在跳过没有执行的函数后，自动的调用Node中的事件循环机制，不断的向刚才的那个没有调用的函数发起循环，你有没有被调用？如果没有过一会有再次询问，你有没有被调用，以此往复直到进程结束。如果在进程结束前他被调用了那么就会输出对应的数据。</p>
<p><img src="http://image.euphie.net/2017-09-24-23-19-53.png" alt=""><br><a href="https://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">参考文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
